var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Flame addon","text":"<p>Flame integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_flame<ul> <li>addon</li> <li>api<ul> <li>batch_utils</li> <li>constants</li> <li>lib</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>render_utils</li> <li>scripts<ul> <li>wiretap_com</li> </ul> </li> <li>utils</li> <li>workio</li> </ul> </li> <li>hooks<ul> <li>pre_flame_setup</li> <li>pre_opentimelineio_install</li> </ul> </li> <li>otio<ul> <li>flame_export</li> <li>tw_bake</li> <li>utils</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_shot_clip</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_clip</li> <li>load_clip_batch</li> </ul> </li> <li>publish<ul> <li>collect_audio</li> <li>collect_plate</li> <li>collect_shots</li> <li>collect_test_selection</li> <li>collect_timeline_otio</li> <li>extract_otio_file</li> <li>extract_product_resources</li> <li>integrate_batch_group</li> <li>validate_product_attributes</li> <li>validate_segments</li> </ul> </li> </ul> </li> <li>startup<ul> <li>AYON_in_flame</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>conversion</li> <li>create_plugins</li> <li>imageio</li> <li>loader_plugins</li> <li>main</li> <li>publish_plugins</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_flame/index.html","title":"ayon_flame","text":""},{"location":"autoapi/client/ayon_flame/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_flame/version.html","title":"version","text":"<p>Package declaring AYON addon 'flame' version.</p>"},{"location":"autoapi/client/ayon_flame/api/index.html","title":"api","text":"<p>AYON Autodesk Flame api</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.ClipLoader","title":"<code>ClipLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic clip loader for Flame</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class ClipLoader(LoaderPlugin):\n    \"\"\"A basic clip loader for Flame\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n    log = log\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Set handles\",\n            default=0,\n            help=\"Also set handles to clip as In/Out marks\"\n        )\n    ]\n\n    _mapping = None\n    _host_settings = None\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n\n        plugin_type_settings = (\n            project_settings\n            .get(\"flame\", {})\n            .get(\"load\", {})\n        )\n\n        if not plugin_type_settings:\n            return\n\n        plugin_name = cls.__name__\n\n        plugin_settings = None\n        # Look for plugin settings in host specific settings\n        if plugin_name in plugin_type_settings:\n            plugin_settings = plugin_type_settings[plugin_name]\n\n        if not plugin_settings:\n            return\n\n        print(\"&gt;&gt;&gt; We have preset for {}\".format(plugin_name))\n        for option, value in plugin_settings.items():\n            if option == \"enabled\" and value is False:\n                print(\"  - is disabled by preset\")\n            elif option == \"representations\":\n                continue\n            else:\n                print(\"  - setting `{}`: `{}`\".format(option, value))\n            setattr(cls, option, value)\n\n    def get_colorspace(self, context):\n        \"\"\"Get colorspace name\n\n        Look either to version data or representation data.\n\n        Args:\n            context (dict): version context data\n\n        Returns:\n            str: colorspace name or None\n        \"\"\"\n        version_entity = context[\"version\"]\n        version_attributes = version_entity[\"attrib\"]\n        colorspace = version_attributes.get(\"colorSpace\")\n\n        if (\n            not colorspace\n            or colorspace == \"Unknown\"\n        ):\n            colorspace = context[\"representation\"][\"data\"].get(\n                \"colorspace\")\n\n        return colorspace\n\n    @classmethod\n    def get_native_colorspace(cls, input_colorspace):\n        \"\"\"Return native colorspace name.\n\n        Args:\n            input_colorspace (str | None): colorspace name\n\n        Returns:\n            str: native colorspace name defined in mapping or None\n        \"\"\"\n        # TODO: rewrite to support only pipeline's remapping\n        if not cls._host_settings:\n            cls._host_settings = get_current_project_settings()[\"flame\"]\n\n        # [Deprecated] way of remapping\n        if not cls._mapping:\n            mapping = (\n                cls._host_settings[\"imageio\"][\"profilesMapping\"][\"inputs\"])\n            cls._mapping = {\n                input[\"ocioName\"]: input[\"flameName\"]\n                for input in mapping\n            }\n\n        native_name = cls._mapping.get(input_colorspace)\n\n        if not native_name:\n            native_name = get_remapped_colorspace_to_native(\n                input_colorspace, \"flame\", cls._host_settings[\"imageio\"])\n\n        return native_name\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.ClipLoader.get_colorspace","title":"<code>get_colorspace(context)</code>","text":"<p>Get colorspace name</p> <p>Look either to version data or representation data.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>version context data</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>colorspace name or None</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>def get_colorspace(self, context):\n    \"\"\"Get colorspace name\n\n    Look either to version data or representation data.\n\n    Args:\n        context (dict): version context data\n\n    Returns:\n        str: colorspace name or None\n    \"\"\"\n    version_entity = context[\"version\"]\n    version_attributes = version_entity[\"attrib\"]\n    colorspace = version_attributes.get(\"colorSpace\")\n\n    if (\n        not colorspace\n        or colorspace == \"Unknown\"\n    ):\n        colorspace = context[\"representation\"][\"data\"].get(\n            \"colorspace\")\n\n    return colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.ClipLoader.get_native_colorspace","title":"<code>get_native_colorspace(input_colorspace)</code>  <code>classmethod</code>","text":"<p>Return native colorspace name.</p> <p>Parameters:</p> Name Type Description Default <code>input_colorspace</code> <code>str | None</code> <p>colorspace name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>native colorspace name defined in mapping or None</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>@classmethod\ndef get_native_colorspace(cls, input_colorspace):\n    \"\"\"Return native colorspace name.\n\n    Args:\n        input_colorspace (str | None): colorspace name\n\n    Returns:\n        str: native colorspace name defined in mapping or None\n    \"\"\"\n    # TODO: rewrite to support only pipeline's remapping\n    if not cls._host_settings:\n        cls._host_settings = get_current_project_settings()[\"flame\"]\n\n    # [Deprecated] way of remapping\n    if not cls._mapping:\n        mapping = (\n            cls._host_settings[\"imageio\"][\"profilesMapping\"][\"inputs\"])\n        cls._mapping = {\n            input[\"ocioName\"]: input[\"flameName\"]\n            for input in mapping\n        }\n\n    native_name = cls._mapping.get(input_colorspace)\n\n    if not native_name:\n        native_name = get_remapped_colorspace_to_native(\n            input_colorspace, \"flame\", cls._host_settings[\"imageio\"])\n\n    return native_name\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.FlameCreator","title":"<code>FlameCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Creator class wrapper</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class FlameCreator(Creator):\n    \"\"\"Creator class wrapper\n    \"\"\"\n    settings_category = \"flame\"\n\n    def __init__(self, *args, **kwargs):\n        super(Creator, self).__init__(*args, **kwargs)\n        project_settings = self.create_context.get_current_project_settings()\n        self.presets = project_settings[\"flame\"][\"create\"].get(\n            self.__class__.__name__, {}\n        )\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Prepare data for new instance creation.\n\n        Args:\n            product_name(str): Product name of created instance.\n            instance_data(dict): Base data for instance.\n            pre_create_data(dict): Data based on pre creation attributes.\n                Those may affect how creator works.\n        \"\"\"\n        # adding basic current context resolve objects\n        self.project = flib.get_current_project()\n        self.sequence = flib.get_current_sequence(flib.CTX.selection)\n\n        selected = pre_create_data.get(\"use_selection\", False)\n        self.selected = flib.get_sequence_segments(\n            self.sequence,\n            selected=selected\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.FlameCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Prepare data for new instance creation.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Product name of created instance.</p> required <code>instance_data</code> <code>dict</code> <p>Base data for instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data based on pre creation attributes. Those may affect how creator works.</p> required Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Prepare data for new instance creation.\n\n    Args:\n        product_name(str): Product name of created instance.\n        instance_data(dict): Base data for instance.\n        pre_create_data(dict): Data based on pre creation attributes.\n            Those may affect how creator works.\n    \"\"\"\n    # adding basic current context resolve objects\n    self.project = flib.get_current_project()\n    self.sequence = flib.get_current_sequence(flib.CTX.selection)\n\n    selected = pre_create_data.get(\"use_selection\", False)\n    self.selected = flib.get_sequence_segments(\n        self.sequence,\n        selected=selected\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.FlameHost","title":"<code>FlameHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>class FlameHost(HostBase, ILoadHost, IPublishHost):\n    name = \"flame\"\n\n    # object variables\n    _publish_context_data = {}\n\n    def get_containers(self):\n        return ls()\n\n    def install(self):\n        \"\"\"Installing all requirements for Nuke host\"\"\"\n        install()\n\n    def get_context_data(self):\n        # TODO: find a way to implement this\n        return deepcopy(self._publish_context_data)\n\n    def update_context_data(self, data, changes):\n        # TODO: find a way to implement this\n        self._publish_context_data = deepcopy(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.FlameHost.install","title":"<code>install()</code>","text":"<p>Installing all requirements for Nuke host</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Installing all requirements for Nuke host\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.HiddenFlameCreator","title":"<code>HiddenFlameCreator</code>","text":"<p>               Bases: <code>HiddenCreator</code></p> <p>HiddenCreator class wrapper</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class HiddenFlameCreator(HiddenCreator):\n    \"\"\"HiddenCreator class wrapper\n    \"\"\"\n    settings_category = \"flame\"\n\n    def collect_instances(self):\n        pass\n\n    def update_instances(self, update_list):\n        pass\n\n    def remove_instances(self, instances):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile","title":"<code>MediaInfoFile</code>","text":"<p>               Bases: <code>object</code></p> <p>Class to get media info file clip data</p> <p>Raises:</p> Type Description <code>IOError</code> <p>MEDIA_SCRIPT_PATH path doesn't exists</p> <code>TypeError</code> <p>Not able to generate clip xml data file</p> <code>ParseError</code> <p>Missing clip in xml clip data</p> <code>IOError</code> <p>Not able to save xml clip data to file</p> <p>Attributes:</p> Name Type Description <code>str</code> <p><code>MEDIA_SCRIPT_PATH</code> path to flame binary</p> <code>logging.Logger</code> <p><code>log</code> logger</p> <p>TODO: add method for getting metadata to dict</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>class MediaInfoFile(object):\n    \"\"\"Class to get media info file clip data\n\n    Raises:\n        IOError: MEDIA_SCRIPT_PATH path doesn't exists\n        TypeError: Not able to generate clip xml data file\n        ET.ParseError: Missing clip in xml clip data\n        IOError: Not able to save xml clip data to file\n\n    Attributes:\n        str: `MEDIA_SCRIPT_PATH` path to flame binary\n        logging.Logger: `log` logger\n\n    TODO: add method for getting metadata to dict\n    \"\"\"\n    MEDIA_SCRIPT_PATH = \"/opt/Autodesk/mio/current/dl_get_media_info\"\n\n    log = log\n\n    _clip_data = None\n    _start_frame = None\n    _fps = None\n    _drop_mode = None\n    _file_pattern = None\n\n    def __init__(self, path, logger=None):\n\n        # replace log if any\n        if logger:\n            self.log = logger\n\n        # test if `dl_get_media_info` path exists\n        self._validate_media_script_path()\n\n        # derivate other feed variables\n        feed_basename = os.path.basename(path)\n        feed_dir = os.path.dirname(path)\n        feed_ext = os.path.splitext(feed_basename)[1][1:].lower()\n\n        with maintained_temp_file_path(\".clip\") as tmp_path:\n            self.log.info(\"Temp File: {}\".format(tmp_path))\n            self._generate_media_info_file(tmp_path, feed_ext, feed_dir)\n\n            # get collection containing feed_basename from path\n            self.file_pattern = self._get_collection(\n                feed_basename, feed_dir, feed_ext)\n\n            if (\n                not self.file_pattern\n                and os.path.exists(os.path.join(feed_dir, feed_basename))\n            ):\n                self.file_pattern = feed_basename\n\n            # get clip data and make them single if there is multiple\n            # clips data\n            xml_data = self._make_single_clip_media_info(\n                tmp_path, feed_basename, self.file_pattern)\n            self.log.debug(\"xml_data: {}\".format(xml_data))\n            self.log.debug(\"type: {}\".format(type(xml_data)))\n\n            # get all time related data and assign them\n            self._get_time_info_from_origin(xml_data)\n            self.log.debug(\"start_frame: {}\".format(self.start_frame))\n            self.log.debug(\"fps: {}\".format(self.fps))\n            self.log.debug(\"drop frame: {}\".format(self.drop_mode))\n            # get all resolution related data and assign them\n            self._get_resolution_info_from_origin(xml_data)\n\n            try:\n                self.log.debug(\"width: {}\".format(self.width))\n                self.log.debug(\"height: {}\".format(self.height))\n                self.log.debug(\"pixel aspect: {}\".format(self.pixel_aspect))\n\n            except AttributeError:\n                self.log.debug(\"audio: true\")\n\n            self.clip_data = xml_data\n\n    def _get_typed_value(self, xml_obj):\n        \"\"\" Get typed value from xml object\n\n        Args:\n            xml_obj (xml.etree.ElementTree.Element): xml object\n\n        Returns:\n            str: value\n        \"\"\"\n        if hasattr(xml_obj, \"type\"):\n            if xml_obj.type in [\"int\", \"uint\"]:\n                return int(xml_obj.text)\n            if xml_obj.type == \"float\":\n                return float(xml_obj.text)\n            if xml_obj.type == \"string\":\n                return str(xml_obj.text)\n\n        return xml_obj.text\n\n    def _get_collection(self, feed_basename, feed_dir, feed_ext) -&gt; str | None:\n        \"\"\"Get collection string.\n\n        Args:\n            feed_basename (str): file base name\n            feed_dir (str): file's directory\n            feed_ext (str): file extension\n\n        Raises:\n            AttributeError: feed_ext is not matching feed_basename\n\n        Returns:\n            str: collection basename with range of sequence\n        \"\"\"\n        partialname = self._separate_file_head(feed_basename, feed_ext)\n\n        # make sure partial input basename is having correct extensoon\n        if not partialname:\n            raise AttributeError(\n                f\"Wrong input attributes. Basename - {feed_basename}, \"\n                f\"Ext - {feed_ext}\"\n            )\n\n        # get all related files\n        files = [\n            f for f in os.listdir(feed_dir)\n            if partialname == self._separate_file_head(f, feed_ext)\n        ]\n\n        # ignore reminders as we dont need them\n        collections = clique.assemble(files)[0]\n\n        # in case no collection found return None\n        # it is probably just single file\n        if not collections:\n            return\n\n        # we expect only one collection\n        collection = collections[0]\n\n        self.log.debug(\"__ collection: {}\".format(collection))\n\n        if collection.is_contiguous():\n            return self._format_collection(collection)\n\n        # add `[` in front to make sure it want capture\n        # shot name with the same number\n        number_from_path = self._separate_number(feed_basename, feed_ext)\n        search_number_pattern = \"[\" + number_from_path\n        # convert to multiple collections\n        _continues_colls = collection.separate()\n        for _coll in _continues_colls:\n            coll_to_text = self._format_collection(\n                _coll, len(number_from_path))\n            self.log.debug(\"__ coll_to_text: {}\".format(coll_to_text))\n            if search_number_pattern in coll_to_text:\n                return coll_to_text\n        return None\n\n    @staticmethod\n    def _format_collection(collection, padding=None):\n        padding = padding or collection.padding\n        # if no holes then return collection\n        head = collection.format(\"{head}\")\n        tail = collection.format(\"{tail}\")\n        range_template = \"[{{:0{0}d}}-{{:0{0}d}}]\".format(\n            padding)\n        ranges = range_template.format(\n            min(collection.indexes),\n            max(collection.indexes)\n        )\n        # if no holes then return collection\n        return \"{}{}{}\".format(head, ranges, tail)\n\n    def _separate_file_head(self, basename, extension):\n        \"\"\" Get only head with out sequence and extension\n\n        Args:\n            basename (str): file base name\n            extension (str): file extension\n\n        Returns:\n            str: file head\n        \"\"\"\n        # in case sequence file\n        found = re.findall(\n            r\"(.*)[._][\\d]*(?=.{})\".format(extension),\n            basename,\n        )\n        if found:\n            return found.pop()\n\n        # in case single file\n        name, ext = os.path.splitext(basename)\n\n        if extension == ext[1:]:\n            return name\n\n    def _separate_number(self, basename, extension):\n        \"\"\" Get only sequence number as string\n\n        Args:\n            basename (str): file base name\n            extension (str): file extension\n\n        Returns:\n            str: number with padding\n        \"\"\"\n        # in case sequence file\n        found = re.findall(\n            r\"[._]([\\d]*)(?=.{})\".format(extension),\n            basename,\n        )\n        if found:\n            return found.pop()\n\n    @property\n    def clip_data(self):\n        \"\"\"Clip's xml clip data\n\n        Returns:\n            xml.etree.ElementTree: xml data\n        \"\"\"\n        return self._clip_data\n\n    @clip_data.setter\n    def clip_data(self, data):\n        self._clip_data = data\n\n    @property\n    def start_frame(self):\n        \"\"\" Clip's starting frame found in timecode\n\n        Returns:\n            int: number of frames\n        \"\"\"\n        return self._start_frame\n\n    @start_frame.setter\n    def start_frame(self, number):\n        self._start_frame = int(number)\n\n    @property\n    def fps(self):\n        \"\"\" Clip's frame rate\n\n        Returns:\n            float: frame rate\n        \"\"\"\n        return self._fps\n\n    @fps.setter\n    def fps(self, fl_number):\n        self._fps = float(fl_number)\n\n    @property\n    def drop_mode(self):\n        \"\"\" Clip's drop frame mode\n\n        Returns:\n            str: drop frame flag\n        \"\"\"\n        return self._drop_mode\n\n    @drop_mode.setter\n    def drop_mode(self, text):\n        self._drop_mode = str(text)\n\n    @property\n    def file_pattern(self):\n        \"\"\"Clips file pattern.\n\n        Returns:\n            str: file pattern. ex. file.[1-2].exr\n        \"\"\"\n        return self._file_pattern\n\n    @file_pattern.setter\n    def file_pattern(self, fpattern):\n        self._file_pattern = fpattern\n\n    def _validate_media_script_path(self):\n        if not os.path.isfile(self.MEDIA_SCRIPT_PATH):\n            raise IOError(\"Media Script does not exist: `{}`\".format(\n                self.MEDIA_SCRIPT_PATH))\n\n    def _generate_media_info_file(self, fpath, feed_ext, feed_dir):\n        \"\"\" Generate media info xml .clip file\n\n        Args:\n            fpath (str): .clip file path\n            feed_ext (str): file extension to be filtered\n            feed_dir (str): look up directory\n\n        Raises:\n            TypeError: Type error if it fails\n        \"\"\"\n        # Create cmd arguments for gettig xml file info file\n        cmd_args = [\n            self.MEDIA_SCRIPT_PATH,\n            \"-e\", feed_ext,\n            \"-o\", fpath,\n            feed_dir\n        ]\n\n        try:\n            # execute creation of clip xml template data\n            run_subprocess(cmd_args)\n        except TypeError as error:\n            raise TypeError(\n                \"Error creating `{}` due: {}\".format(fpath, error))\n\n    def _make_single_clip_media_info(self, fpath, feed_basename, path_pattern):\n        \"\"\" Separate only relative clip object form .clip file\n\n        Args:\n            fpath (str): clip file path\n            feed_basename (str): search basename\n            path_pattern (str): search file pattern (file.[1-2].exr)\n\n        Raises:\n            ET.ParseError: if nothing found\n\n        Returns:\n            ET.Element: xml element data of matching clip\n        \"\"\"\n        with open(fpath) as f:\n            lines = f.readlines()\n            _added_root = itertools.chain(\n                \"&lt;root&gt;\", deepcopy(lines)[1:], \"&lt;/root&gt;\")\n            new_root = ET.fromstringlist(_added_root)\n\n        # find the clip which is matching to my input name\n        xml_clips = new_root.findall(\"clip\")\n        matching_clip = None\n        for xml_clip in xml_clips:\n            clip_name = xml_clip.find(\"name\").text\n            self.log.debug(\"__ clip_name: `{}`\".format(clip_name))\n            if clip_name not in feed_basename:\n                continue\n\n            # test path pattern\n            for out_track in xml_clip.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    for span in out_feed.iter(\"span\"):\n                        # start frame\n                        span_path = span.find(\"path\")\n                        self.log.debug(\n                            \"__ span_path.text: {}, path_pattern: {}\".format(\n                                span_path.text, path_pattern\n                            )\n                        )\n                        if path_pattern in span_path.text:\n                            matching_clip = xml_clip\n\n        if matching_clip is None:\n            # return warning there is missing clip\n            raise ET.ParseError(\n                \"Missing clip in `{}`. Available clips {}\".format(\n                    feed_basename, [\n                        xml_clip.find(\"name\").text\n                        for xml_clip in xml_clips\n                    ]\n                ))\n\n        return matching_clip\n\n    def _get_time_info_from_origin(self, xml_data):\n        \"\"\"Set time info to class attributes\n\n        Args:\n            xml_data (ET.Element): clip data\n        \"\"\"\n        try:\n            for out_track in xml_data.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    # start frame\n                    out_feed_nb_ticks_obj = out_feed.find(\n                        \"startTimecode/nbTicks\")\n                    self.start_frame = self._get_typed_value(\n                        out_feed_nb_ticks_obj)\n\n                    # fps\n                    out_feed_fps_obj = out_feed.find(\n                        \"startTimecode/rate\")\n                    self.fps = self._get_typed_value(out_feed_fps_obj)\n\n                    # drop frame mode\n                    out_feed_drop_mode_obj = out_feed.find(\n                        \"startTimecode/dropMode\")\n                    self.drop_mode = self._get_typed_value(\n                        out_feed_drop_mode_obj)\n                    break\n        except Exception as msg:\n            self.log.warning(msg)\n\n    def _get_resolution_info_from_origin(self, xml_data):\n        \"\"\"Set resolution info to class attributes\n\n        Args:\n            xml_data (ET.Element): clip data\n        \"\"\"\n        try:\n            for out_track in xml_data.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    # width\n                    out_feed_width_obj = out_feed.find(\"storageFormat/width\")\n                    self.width = int(self._get_typed_value(out_feed_width_obj))\n\n                    # height\n                    out_feed_height_obj = out_feed.find(\"storageFormat/height\")\n                    self.height = int(\n                        self._get_typed_value(out_feed_height_obj))\n\n                    # pixel aspect ratio\n                    out_feed_pixel_aspect_obj = out_feed.find(\n                        \"storageFormat/pixelRatio\")\n                    self.pixel_aspect = float(\n                        self._get_typed_value(out_feed_pixel_aspect_obj))\n                    break\n        except Exception as msg:\n            self.log.warning(msg)\n\n    @staticmethod\n    def write_clip_data_to_file(fpath, xml_element_data):\n        \"\"\" Write xml element of clip data to file\n\n        Args:\n            fpath (string): file path\n            xml_element_data (xml.etree.ElementTree.Element): xml data\n\n        Raises:\n            IOError: If data could not be written to file\n        \"\"\"\n        try:\n            # save it as new file\n            tree = cET.ElementTree(xml_element_data)\n            tree.write(\n                fpath, xml_declaration=True,\n                method=\"xml\", encoding=\"UTF-8\"\n            )\n        except IOError as error:\n            raise IOError(\n                \"Not able to write data to file: {}\".format(error))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.clip_data","title":"<code>clip_data</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's xml clip data</p> <p>Returns:</p> Type Description <p>xml.etree.ElementTree: xml data</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.drop_mode","title":"<code>drop_mode</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's drop frame mode</p> <p>Returns:</p> Name Type Description <code>str</code> <p>drop frame flag</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.file_pattern","title":"<code>file_pattern</code>  <code>property</code> <code>writable</code>","text":"<p>Clips file pattern.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>file pattern. ex. file.[1-2].exr</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.fps","title":"<code>fps</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's frame rate</p> <p>Returns:</p> Name Type Description <code>float</code> <p>frame rate</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.start_frame","title":"<code>start_frame</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's starting frame found in timecode</p> <p>Returns:</p> Name Type Description <code>int</code> <p>number of frames</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.MediaInfoFile.write_clip_data_to_file","title":"<code>write_clip_data_to_file(fpath, xml_element_data)</code>  <code>staticmethod</code>","text":"<p>Write xml element of clip data to file</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>string</code> <p>file path</p> required <code>xml_element_data</code> <code>Element</code> <p>xml data</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If data could not be written to file</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@staticmethod\ndef write_clip_data_to_file(fpath, xml_element_data):\n    \"\"\" Write xml element of clip data to file\n\n    Args:\n        fpath (string): file path\n        xml_element_data (xml.etree.ElementTree.Element): xml data\n\n    Raises:\n        IOError: If data could not be written to file\n    \"\"\"\n    try:\n        # save it as new file\n        tree = cET.ElementTree(xml_element_data)\n        tree.write(\n            fpath, xml_declaration=True,\n            method=\"xml\", encoding=\"UTF-8\"\n        )\n    except IOError as error:\n        raise IOError(\n            \"Not able to write data to file: {}\".format(error))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.OpenClipSolver","title":"<code>OpenClipSolver</code>","text":"<p>               Bases: <code>MediaInfoFile</code></p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class OpenClipSolver(flib.MediaInfoFile):\n    create_new_clip = False\n\n    log = log\n\n    def __init__(self, openclip_file_path, feed_data, logger=None):\n        self.out_file = openclip_file_path\n\n        # replace log if any\n        if logger:\n            self.log = logger\n\n        # new feed variables:\n        feed_path = feed_data.pop(\"path\")\n\n        # initialize parent class\n        super(OpenClipSolver, self).__init__(\n            feed_path,\n            logger=logger\n        )\n\n        # get other metadata\n        self.feed_version_name = feed_data[\"version\"]\n        self.feed_colorspace = feed_data.get(\"colorspace\")\n        self.log.debug(\"feed_version_name: {}\".format(self.feed_version_name))\n\n        # layer rename variables\n        self.layer_rename_template = feed_data[\"layer_rename_template\"]\n        self.layer_rename_patterns = feed_data[\"layer_rename_patterns\"]\n        self.context_data = feed_data[\"context_data\"]\n\n        # derivate other feed variables\n        self.feed_basename = os.path.basename(feed_path)\n        self.feed_dir = os.path.dirname(feed_path)\n        self.feed_ext = os.path.splitext(self.feed_basename)[1][1:].lower()\n        self.log.debug(\"feed_ext: {}\".format(self.feed_ext))\n        self.log.debug(\"out_file: {}\".format(self.out_file))\n        if not self._is_valid_tmp_file(self.out_file):\n            self.create_new_clip = True\n\n    def _is_valid_tmp_file(self, file):\n        # check if file exists\n        if os.path.isfile(file):\n            # test also if file is not empty\n            with open(file) as f:\n                lines = f.readlines()\n\n            if len(lines) &gt; 2:\n                return True\n\n            # file is probably corrupted\n            os.remove(file)\n            return False\n\n    def make(self):\n\n        if self.create_new_clip:\n            # New openClip\n            self._create_new_open_clip()\n        else:\n            self._update_open_clip()\n\n    def _clear_handler(self, xml_object):\n        for handler in xml_object.findall(\"./handler\"):\n            self.log.info(\"Handler found\")\n            xml_object.remove(handler)\n\n    def _create_new_open_clip(self):\n        self.log.info(\"Building new openClip\")\n\n        for tmp_xml_track in self.clip_data.iter(\"track\"):\n            # solve track (layer) name\n            self._rename_track_name(tmp_xml_track)\n\n            tmp_xml_feeds = tmp_xml_track.find('feeds')\n            tmp_xml_feeds.set('currentVersion', self.feed_version_name)\n\n            for tmp_feed in tmp_xml_track.iter(\"feed\"):\n                tmp_feed.set('vuid', self.feed_version_name)\n\n                # add colorspace if any is set\n                if self.feed_colorspace:\n                    self._add_colorspace(tmp_feed, self.feed_colorspace)\n\n                self._clear_handler(tmp_feed)\n\n        tmp_xml_versions_obj = self.clip_data.find('versions')\n        tmp_xml_versions_obj.set('currentVersion', self.feed_version_name)\n        for xml_new_version in tmp_xml_versions_obj:\n            xml_new_version.set('uid', self.feed_version_name)\n            xml_new_version.set('type', 'version')\n\n        self._clear_handler(self.clip_data)\n        self.log.info(\"Adding feed version: {}\".format(self.feed_basename))\n\n        self.write_clip_data_to_file(self.out_file, self.clip_data)\n\n    def _get_xml_track_obj_by_uid(self, xml_data, uid):\n        # loop all tracks of input xml data\n        for xml_track in xml_data.iter(\"track\"):\n            track_uid = xml_track.get(\"uid\")\n            self.log.debug(\n                \"&gt;&gt; track_uid:uid: {}:{}\".format(track_uid, uid))\n\n            # get matching uids\n            if uid == track_uid:\n                return xml_track\n\n    def _rename_track_name(self, xml_track_data):\n        layer_uid = xml_track_data.get(\"uid\")\n        name_obj = xml_track_data.find(\"name\")\n        layer_name = name_obj.text\n\n        if (\n            self.layer_rename_patterns\n            and not any(\n                re.search(lp_.lower(), layer_name.lower())\n                for lp_ in self.layer_rename_patterns\n            )\n        ):\n            return\n\n        formatting_data = self._update_formatting_data(\n            layerName=layer_name,\n            layerUID=layer_uid\n        )\n        name_obj.text = StringTemplate(\n            self.layer_rename_template\n        ).format(formatting_data)\n\n    def _update_formatting_data(self, **kwargs):\n        \"\"\" Updating formatting data for layer rename\n\n        Attributes:\n            key=value (optional): will be included to formatting data\n                                  as {key: value}\n        Returns:\n            dict: anatomy context data for formatting\n        \"\"\"\n        self.log.debug(\"&gt;&gt; self.clip_data: {}\".format(self.clip_data))\n        clip_name_obj = self.clip_data.find(\"name\")\n        data = {\n            \"originalBasename\": clip_name_obj.text\n        }\n        # include version context data\n        data.update(self.context_data)\n        # include input kwargs data\n        data.update(kwargs)\n        return data\n\n    def _update_open_clip(self):\n        self.log.info(\"Updating openClip ..\")\n\n        out_xml = ET.parse(self.out_file)\n        out_xml = out_xml.getroot()\n\n        self.log.debug(\"&gt;&gt; out_xml: {}\".format(out_xml))\n        # loop tmp tracks\n        updated_any = False\n        for tmp_xml_track in self.clip_data.iter(\"track\"):\n            # solve track (layer) name\n            self._rename_track_name(tmp_xml_track)\n\n            # get tmp track uid\n            tmp_track_uid = tmp_xml_track.get(\"uid\")\n            self.log.debug(\"&gt;&gt; tmp_track_uid: {}\".format(tmp_track_uid))\n\n            # get out data track by uid\n            out_track_element = self._get_xml_track_obj_by_uid(\n                out_xml, tmp_track_uid)\n            self.log.debug(\n                \"&gt;&gt; out_track_element: {}\".format(out_track_element))\n\n            # loop tmp feeds\n            for tmp_xml_feed in tmp_xml_track.iter(\"feed\"):\n                new_path_obj = tmp_xml_feed.find(\n                    \"spans/span/path\")\n                new_path = new_path_obj.text\n\n                # check if feed path already exists in track's feeds\n                if (\n                    out_track_element is not None\n                    and self._feed_exists(out_track_element, new_path)\n                ):\n                    continue\n\n                # rename versions on feeds\n                tmp_xml_feed.set('vuid', self.feed_version_name)\n                self._clear_handler(tmp_xml_feed)\n\n                # update fps from MediaInfoFile class\n                if self.fps is not None:\n                    tmp_feed_fps_obj = tmp_xml_feed.find(\n                        \"startTimecode/rate\")\n                    tmp_feed_fps_obj.text = str(self.fps)\n\n                # update start_frame from MediaInfoFile class\n                if self.start_frame is not None:\n                    tmp_feed_nb_ticks_obj = tmp_xml_feed.find(\n                        \"startTimecode/nbTicks\")\n                    tmp_feed_nb_ticks_obj.text = str(self.start_frame)\n\n                # update drop_mode from MediaInfoFile class\n                if self.drop_mode is not None:\n                    tmp_feed_drop_mode_obj = tmp_xml_feed.find(\n                        \"startTimecode/dropMode\")\n                    tmp_feed_drop_mode_obj.text = str(self.drop_mode)\n\n                # add colorspace if any is set\n                if self.feed_colorspace is not None:\n                    self._add_colorspace(tmp_xml_feed, self.feed_colorspace)\n\n                # then append/update feed to correct track in output\n                if out_track_element:\n                    self.log.debug(\"updating track element ..\")\n                    # update already present track\n                    out_feeds = out_track_element.find('feeds')\n                    out_feeds.set('currentVersion', self.feed_version_name)\n                    out_feeds.append(tmp_xml_feed)\n\n                    self.log.info(\n                        \"Appending new feed: {}\".format(\n                            self.feed_version_name))\n                else:\n                    self.log.debug(\"adding new track element ..\")\n                    # create new track as it doesn't exist yet\n                    # set current version to feeds on tmp\n                    tmp_xml_feeds = tmp_xml_track.find('feeds')\n                    tmp_xml_feeds.set('currentVersion', self.feed_version_name)\n                    out_tracks = out_xml.find(\"tracks\")\n                    out_tracks.append(tmp_xml_track)\n\n                updated_any = True\n\n        if updated_any:\n            # Append vUID to versions\n            out_xml_versions_obj = out_xml.find('versions')\n            out_xml_versions_obj.set(\n                'currentVersion', self.feed_version_name)\n            new_version_obj = ET.Element(\n                \"version\", {\"type\": \"version\", \"uid\": self.feed_version_name})\n            out_xml_versions_obj.insert(0, new_version_obj)\n\n            self._clear_handler(out_xml)\n\n            # fist create backup\n            self._create_openclip_backup_file(self.out_file)\n\n            self.log.info(\"Adding feed version: {}\".format(\n                self.feed_version_name))\n\n            self.write_clip_data_to_file(self.out_file, out_xml)\n\n            self.log.debug(\"OpenClip Updated: {}\".format(self.out_file))\n\n    def _feed_exists(self, xml_data, path):\n        # loop all available feed paths and check if\n        # the path is not already in file\n        for src_path in xml_data.iter('path'):\n            if path == src_path.text:\n                self.log.warning(\n                    \"Not appending file as it already is in .clip file\")\n                return True\n\n    def _create_openclip_backup_file(self, file):\n        bck_file = \"{}.bak\".format(file)\n        # if backup does not exist\n        if not os.path.isfile(bck_file):\n            shutil.copy2(file, bck_file)\n        else:\n            # in case it exists and is already multiplied\n            created = False\n            for _i in range(1, 99):\n                bck_file = \"{name}.bak.{idx:0&gt;2}\".format(\n                    name=file,\n                    idx=_i)\n                # create numbered backup file\n                if not os.path.isfile(bck_file):\n                    shutil.copy2(file, bck_file)\n                    created = True\n                    break\n            # in case numbered does not exists\n            if not created:\n                bck_file = \"{}.bak.last\".format(file)\n                shutil.copy2(file, bck_file)\n\n    def _add_colorspace(self, feed_obj, profile_name):\n        feed_storage_obj = feed_obj.find(\"storageFormat\")\n        feed_clr_obj = feed_storage_obj.find(\"colourSpace\")\n        if feed_clr_obj is not None:\n            feed_clr_obj = ET.Element(\n                \"colourSpace\", {\"type\": \"string\"})\n            feed_clr_obj.text = profile_name\n            feed_storage_obj.append(feed_clr_obj)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.PublishableClip","title":"<code>PublishableClip</code>","text":"<p>Convert a segment to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>PySegment</code> <p>flame api object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>flame.PySegment: flame api object</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class PublishableClip:\n    \"\"\"\n    Convert a segment to publishable instance\n\n    Args:\n        segment (flame.PySegment): flame api object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        flame.PySegment: flame api object\n    \"\"\"\n    vertical_clip_match = {}\n    vertical_clip_used = {}\n    marker_data = {}\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    review_source_default = None\n    base_product_variant_default = \"&lt;track_name&gt;\"\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n    index_from_segment_default = False\n    use_shot_name_default = False\n    include_handles_default = False\n    retimed_handles_default = True\n    retimed_framerange_default = True\n\n    def __init__(self,\n            segment,\n            pre_create_data=None,\n            data=None,\n            product_type=None,\n            rename_index=None,\n            log=None,\n        ):\n        self.rename_index = rename_index\n        self.product_type = product_type\n        self.log = log\n        self.pre_create_data = pre_create_data or {}\n\n        # get main parent objects\n        self.current_segment = segment\n        sequence_name = flib.get_current_sequence([segment]).name.get_value()\n        self.sequence_name = str(sequence_name).replace(\" \", \"_\")\n        self.clip_data = flib.get_segment_attributes(segment)\n\n        # segment (clip) main attributes\n        self.cs_name = self.clip_data[\"segment_name\"]\n        self.cs_index = int(self.clip_data[\"segment\"])\n        self.shot_name = self.clip_data[\"shot_name\"]\n\n        # get track name and index\n        self.track_index = int(self.clip_data[\"track\"])\n        track_name = self.clip_data[\"track_name\"]\n        self.track_name = (\n            # make sure no space and other special characters are in track name\n            # default track name is `*`\n            str(track_name)\n            .replace(\" \", \"_\")\n            .replace(\"*\", f\"noname{self.track_index}\")\n        )\n\n        # add publish attribute to marker data\n        self.marker_data.update({\"active\": True})\n\n        # adding input data if any\n        if data:\n            self.marker_data.update(data)\n\n        # populate default data before we get other attributes\n        self._populate_segment_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    @classmethod\n    def restore_all_caches(cls):\n        cls.vertical_clip_match = {}\n        cls.vertical_clip_used = {}\n\n    def convert(self):\n\n        # solve segment data and add them to marker data\n        self._convert_to_marker_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (self.track_name in self.reviewable_source) and (\n                self.driving_layer not in self.reviewable_source):\n            return\n\n        # deal with clip name\n        new_name = self.marker_data.pop(\"newClipName\")\n        hierarchy_filled = self.marker_data[\"hierarchy\"]\n\n        if self.rename and not self.use_shot_name:\n            # rename segment\n            self.current_segment.name = str(new_name)\n            self.marker_data.update({\n                \"folderName\": str(new_name),\n                \"folderPath\": f\"/{hierarchy_filled}/{new_name}\"\n            })\n\n        elif self.use_shot_name:\n            if not self.shot_name:\n                raise CreatorError(\n                    f\"Shot name is not set on segment: {self.cs_name}\")\n            self.marker_data.update({\n                \"folderName\": self.shot_name,\n                \"folderPath\": f\"/{hierarchy_filled}/{self.shot_name}\",\n                \"hierarchyData\": {\n                    \"shot\": self.shot_name\n                }\n            })\n        else:\n            self.marker_data.update({\n                \"folderName\": self.cs_name,\n                \"folderPath\": f\"/{hierarchy_filled}/{self.cs_name}\",\n                \"hierarchyData\": {\n                    \"shot\": self.cs_name\n                }\n            })\n\n        return self.current_segment\n\n    def _populate_segment_default_data(self):\n        \"\"\" Populate default formatting data from segment. \"\"\"\n\n        self.current_segment_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.sequence_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.cs_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.cs_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # segment frame range and parent track name for vertical sync check\n        self.clip_in = int(self.clip_data[\"record_in\"])\n        self.clip_out = int(self.clip_data[\"record_out\"])\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.cs_index\n        self.log.debug(f\"____ self.shot_num: {self.shot_num}\")\n\n        # Use pre-create data or default values if gui was not used\n        self.rename = self.pre_create_data.get(\n            \"clipRename\") or self.rename_default\n        self.use_shot_name = self.pre_create_data.get(\n            \"useShotName\") or self.use_shot_name_default\n        self.clip_name = self.pre_create_data.get(\n            \"clipName\") or self.clip_name_default\n        self.hierarchy = self.pre_create_data.get(\n            \"hierarchy\") or self.hierarchy_default\n        self.hierarchy_data = self.pre_create_data.get(\n            \"hierarchyData\") or self.current_segment_default_data.copy()\n        self.index_from_segment = self.pre_create_data.get(\n            \"segmentIndex\") or self.index_from_segment_default\n        self.count_from = self.pre_create_data.get(\n            \"countFrom\") or self.count_from_default\n        self.count_steps = self.pre_create_data.get(\n            \"countSteps\") or self.count_steps_default\n        self.base_product_variant = self.pre_create_data.get(\n            \"clipVariant\") or self.base_product_variant_default\n        self.product_type = (\n            self.pre_create_data.get(\"productType\")\n            or self.product_type_default\n        )\n        self.vertical_sync = self.pre_create_data.get(\n            \"vSyncOn\") or self.vertical_sync_default\n        self.driving_layer = self.pre_create_data.get(\n            \"vSyncTrack\") or self.driving_layer_default\n        self.review_source = self.pre_create_data.get(\n            \"reviewableSource\") or self.review_source_default\n        self.audio = self.pre_create_data.get(\"export_audio\") or False\n        self.include_handles = self.pre_create_data.get(\n            \"includeHandles\") or self.include_handles_default\n        self.retimed_handles = (\n            self.pre_create_data.get(\"retimedHandles\")\n            or self.retimed_handles_default\n        )\n        self.retimed_framerange = (\n            self.pre_create_data.get(\"retimedFramerange\")\n            or self.retimed_framerange_default\n        )\n\n        # build product name from layer name\n        if self.base_product_variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n        else:\n            self.variant = self.base_product_variant\n\n        # create product for publishing\n        self.product_name = (\n            self.product_type + self.variant.capitalize()\n        )\n\n        self.hierarchy_data = {\n            key: self.pre_create_data.get(key)\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        return text.replace((\"#\" * _len), _repl)\n\n    def _convert_to_marker_data(self):\n        \"\"\" Convert internal data to marker data.\n\n        Populating the marker data into internal variable self.marker_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n\n        if (\n            self.vertical_sync and\n            self.track_name not in self.driving_layer\n        ):\n            # if it is not then define vertical sync as None\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        if not self.index_from_segment:\n            self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        hierarchy_data = deepcopy(self.hierarchy_data)\n        _data = self.current_segment_default_data.copy()\n\n        if self.pre_create_data:\n\n            # backward compatibility for reviewableSource (2024.12.02)\n            if \"reviewTrack\" in self.pre_create_data:\n                _value = self.marker_data.pop(\"reviewTrack\")\n                self.marker_data[\"reviewableSource\"] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review layer\n                if self.review_source and (\n                        self.review_source != self.review_source_default):\n                    # if review layer is defined and not the same as default\n                    self.reviewable_source  = self.review_source\n\n                # shot num calculate\n                if self.index_from_segment:\n                    # use clip index from timeline\n                    self.shot_num = self.count_steps * self.cs_index\n                else:\n                    if self.rename_index == 0:\n                        self.shot_num = self.count_from\n                    else:\n                        self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _k, _v in hierarchy_data.items():\n                if \"#\" not in _v:\n                    continue\n                hierarchy_data[_k] = self._replace_hash_to_expression(_k, _v)\n\n            # fill up pythonic expresisons in hierarchy data\n            for k, _v in hierarchy_data.items():\n                hierarchy_formatting_data[k] = str(_v).format(**_data)\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = hierarchy_data\n\n        tag_instance_data = self._solve_tag_instance_data(\n            hierarchy_formatting_data)\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update({\n                (self.clip_in, self.clip_out): tag_instance_data\n            })\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\" Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", []\n                )\n                self.log.debug(\n                    f\"&gt;&gt; used_names_list: {used_names_list}\"\n                )\n                clip_product_name = self.product_name\n                variant = self.variant\n                self.log.debug(\n                    f\"&gt;&gt; clip_product_name: {clip_product_name}\")\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    _clip_product_name = (\n                        f\"{clip_product_name}{self.cs_index}\"\n                    )\n                    # just in case lets validate if new name is not used\n                    # in case the track_index is the same as clip_index\n                    if _clip_product_name in used_names_list:\n                        _clip_product_name = (\n                            f\"{clip_product_name}\"\n                            f\"{self.track_index}{self.cs_index}\"\n                        )\n                    clip_product_name = _clip_product_name\n                    variant = f\"{variant}{self.cs_index}\"\n\n                self.log.debug(\n                    f\"&gt;&gt; clip_product_name: {clip_product_name}\")\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.marker_data.update(tag_instance_data)\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.marker_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.marker_data[\"reviewTrack\"] = None\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.marker_data[\"review\"] = True\n            else:\n                self.marker_data.pop(\"review\", None)\n\n            self.marker_data[\"reviewableSource\"] = reviewable_source\n\n    def _solve_tag_instance_data(self, hierarchy_formatting_data):\n        \"\"\" Solve marker data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        # remove shot from hierarchy data: is not needed anymore\n        hierarchy_formatting_data.pop(\"shot\")\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type_default,\n            \"variant\": self.variant,\n        }\n\n    def _convert_to_entity(self, src_type, template):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(src_type, None)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            src_type\n        )\n\n        # first collect formatting data to use for formatting template\n        formatting_data = {}\n        for _k, _v in self.hierarchy_data.items():\n            value = str(_v).format(\n                **self.current_segment_default_data)\n            formatting_data[_k] = value\n\n        return {\n            \"folder_type\": folder_type,\n            \"entity_name\": template.format(\n                **formatting_data\n            )\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n\n        par_split = [(pattern.findall(t).pop(), t)\n                     for t in self.hierarchy.split(\"/\")]\n\n        for type, template in par_split:\n            parent = self._convert_to_entity(type, template)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.TimeEffectMetadata","title":"<code>TimeEffectMetadata</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>class TimeEffectMetadata(object):\n    log = log\n    _data = {}\n    _retime_modes = {\n        0: \"speed\",\n        1: \"timewarp\",\n        2: \"duration\"\n    }\n\n    def __init__(self, segment, logger=None):\n        if logger:\n            self.log = logger\n\n        self._setup_data, self._data = self._get_metadata(segment)\n\n    @property\n    def is_empty(self):\n        \"\"\" Returns either the current object is empty or not.\n\n        Returns:\n            bool. Is the TimeEffectMetadata object empty?\n        \"\"\"\n        return self._setup_data is None\n\n    @property\n    def data(self):\n        \"\"\" Returns timewarp effect data\n\n        Returns:\n            dict: retime data\n        \"\"\"\n        return self._data\n\n    @property\n    def setup_data(self):\n        \"\"\" Returns timewarp effect setup data\n\n        Returns:\n            str. The XML formatted setup data.\n        \"\"\"\n        return self._setup_data\n\n    def _get_metadata(self, segment):\n        effects = segment.effects or []\n        for effect in effects:\n            if effect.type == \"Timewarp\":\n                with maintained_temp_file_path(\".timewarp_node\") as tmp_path:\n                    self.log.info(\"Temp File: {}\".format(tmp_path))\n                    effect.save_setup(tmp_path)\n                    return self._get_attributes_from_xml(tmp_path)\n\n        return None, {}\n\n    def _get_attributes_from_xml(self, tmp_path):\n        with open(tmp_path, \"r\") as tw_setup_file:\n            tw_setup_string = tw_setup_file.read()\n            tw_setup_file.close()\n\n        tw_setup_xml = ET.fromstring(tw_setup_string)\n        tw_setup = self._dictify(tw_setup_xml)\n        # pprint(tw_setup)\n        try:\n            tw_setup_state = tw_setup[\"Setup\"][\"State\"][0]\n            mode = int(\n                tw_setup_state[\"TW_RetimerMode\"][0][\"_text\"]\n            )\n            r_data = {\n                \"type\": self._retime_modes[mode],\n                \"effectStart\": int(\n                    tw_setup[\"Setup\"][\"Base\"][0][\"Range\"][0][\"Start\"]),\n                \"effectEnd\": int(\n                    tw_setup[\"Setup\"][\"Base\"][0][\"Range\"][0][\"End\"])\n            }\n\n            if mode == 0:  # speed\n                r_data[self._retime_modes[mode]] = float(\n                    tw_setup_state[\"TW_Speed\"]\n                    [0][\"Channel\"][0][\"Value\"][0][\"_text\"]\n                ) / 100\n                r_data[\"numKeys\"] = int(\n                    tw_setup_state[\"TW_SpeedTiming\"]\n                    [0][\"Channel\"][0][\"Size\"][0][\"_text\"]\n                )\n            elif mode == 1:  # timewarp\n                r_data[self._retime_modes[mode]] = self._get_anim_keys(\n                    tw_setup_state[\"TW_Timing\"]\n                )\n            elif mode == 2:  # duration\n                r_data[self._retime_modes[mode]] = {\n                    \"start\": {\n                        \"source\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][0][\"Value\"][0][\"_text\"]\n                        ),\n                        \"timeline\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][0][\"Frame\"][0][\"_text\"]\n                        )\n                    },\n                    \"end\": {\n                        \"source\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][1][\"Value\"][0][\"_text\"]\n                        ),\n                        \"timeline\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][1][\"Frame\"][0][\"_text\"]\n                        )\n                    }\n                }\n        except Exception:\n            lines = traceback.format_exception(*sys.exc_info())\n            self.log.error(\"\\n\".join(lines))\n            return None, {}\n\n        return tw_setup_string, r_data\n\n    def _get_anim_keys(self, setup_cat, index=None):\n        return_data = {\n            \"extrapolation\": (\n                setup_cat[0][\"Channel\"][0][\"Extrap\"][0][\"_text\"]\n            ),\n            \"animKeys\": []\n        }\n        for key in setup_cat[0][\"Channel\"][0][\"KFrames\"][0][\"Key\"]:\n            if index and int(key[\"Index\"]) != index:\n                continue\n            key_data = {\n                \"source\": float(key[\"Value\"][0][\"_text\"]),\n                \"timeline\": float(key[\"Frame\"][0][\"_text\"]),\n                \"index\": int(key[\"Index\"]),\n                \"curveMode\": key[\"CurveMode\"][0][\"_text\"],\n                \"curveOrder\": key[\"CurveOrder\"][0][\"_text\"]\n            }\n            if key.get(\"TangentMode\"):\n                key_data[\"tangentMode\"] = key[\"TangentMode\"][0][\"_text\"]\n\n            return_data[\"animKeys\"].append(key_data)\n\n        return return_data\n\n    def _dictify(self, xml_, root=True):\n        \"\"\" Convert xml object to dictionary\n\n        Args:\n            xml_ (xml.etree.ElementTree.Element): xml data\n            root (bool, optional): is root available. Defaults to True.\n\n        Returns:\n            dict: dictionarized xml\n        \"\"\"\n\n        if root:\n            return {xml_.tag: self._dictify(xml_, False)}\n\n        d = copy(xml_.attrib)\n        if xml_.text:\n            d[\"_text\"] = xml_.text\n\n        for x in xml_.findall(\"./*\"):\n            if x.tag not in d:\n                d[x.tag] = []\n            d[x.tag].append(self._dictify(x, False))\n        return d\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.TimeEffectMetadata.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns timewarp effect data</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>retime data</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.TimeEffectMetadata.is_empty","title":"<code>is_empty</code>  <code>property</code>","text":"<p>Returns either the current object is empty or not.</p> <p>Returns:</p> Type Description <p>bool. Is the TimeEffectMetadata object empty?</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.TimeEffectMetadata.setup_data","title":"<code>setup_data</code>  <code>property</code>","text":"<p>Returns timewarp effect setup data</p> <p>Returns:</p> Type Description <p>str. The XML formatted setup data.</p>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.create_batch_group","title":"<code>create_batch_group(name, frame_start, frame_duration, update_batch_group=None, **kwargs)</code>","text":"<p>Create Batch Group in active project's Desktop</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of batch group to be created</p> required <code>frame_start</code> <code>int</code> <p>start frame of batch</p> required <code>frame_end</code> <code>int</code> <p>end frame of batch</p> required <code>update_batch_group (PyBatch)[optional]</code> <p>batch group to update</p> required Return <p>PyBatch: active flame batch group</p> Source code in <code>client/ayon_flame/api/batch_utils.py</code> <pre><code>def create_batch_group(\n    name,\n    frame_start,\n    frame_duration,\n    update_batch_group=None,\n    **kwargs\n):\n    \"\"\"Create Batch Group in active project's Desktop\n\n    Args:\n        name (str): name of batch group to be created\n        frame_start (int): start frame of batch\n        frame_end (int): end frame of batch\n        update_batch_group (PyBatch)[optional]: batch group to update\n\n    Return:\n        PyBatch: active flame batch group\n    \"\"\"\n    # make sure some batch obj is present\n    batch_group = update_batch_group or flame.batch\n\n    schematic_reels = kwargs.get(\"shematic_reels\") or ['LoadedReel1']\n    shelf_reels = kwargs.get(\"shelf_reels\") or ['ShelfReel1']\n\n    handle_start = kwargs.get(\"handleStart\") or 0\n    handle_end = kwargs.get(\"handleEnd\") or 0\n\n    frame_start -= handle_start\n    frame_duration += handle_start + handle_end\n\n    if not update_batch_group:\n        # Create batch group with name, start_frame value, duration value,\n        # set of schematic reel names, set of shelf reel names\n        batch_group = batch_group.create_batch_group(\n            name,\n            start_frame=frame_start,\n            duration=frame_duration,\n            reels=schematic_reels,\n            shelf_reels=shelf_reels\n        )\n    else:\n        batch_group.name = name\n        batch_group.start_frame = frame_start\n        batch_group.duration = frame_duration\n\n        # add reels to batch group\n        _add_reels_to_batch_group(\n            batch_group, schematic_reels, shelf_reels)\n\n        # TODO: also update write node if there is any\n        # TODO: also update loaders to start from correct frameStart\n\n    if kwargs.get(\"switch_batch_tab\"):\n        # use this command to switch to the batch tab\n        batch_group.go_to()\n\n    return batch_group\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.create_batch_group_conent","title":"<code>create_batch_group_conent(batch_nodes, batch_links, batch_group=None)</code>","text":"<p>Creating batch group with links</p> <p>Parameters:</p> Name Type Description Default <code>batch_nodes</code> <code>list of dict</code> <p>each dict is node definition</p> required <code>batch_links</code> <code>list of dict</code> <p>each dict is link definition</p> required <code>batch_group</code> <code>PyBatch</code> <p>batch group. Defaults to None.</p> <code>None</code> Return <p>dict: all batch nodes {name or id: PyNode}</p> Source code in <code>client/ayon_flame/api/batch_utils.py</code> <pre><code>def create_batch_group_conent(batch_nodes, batch_links, batch_group=None):\n    \"\"\"Creating batch group with links\n\n    Args:\n        batch_nodes (list of dict): each dict is node definition\n        batch_links (list of dict): each dict is link definition\n        batch_group (PyBatch, optional): batch group. Defaults to None.\n\n    Return:\n        dict: all batch nodes {name or id: PyNode}\n    \"\"\"\n    # make sure some batch obj is present\n    batch_group = batch_group or flame.batch\n    all_batch_nodes = {\n        b.name.get_value(): b\n        for b in batch_group.nodes\n    }\n    for node in batch_nodes:\n        # NOTE: node_props needs to be ideally OrederDict type\n        node_id, node_type, node_props = (\n            node[\"id\"], node[\"type\"], node[\"properties\"])\n\n        # get node name for checking if exists\n        node_name = node_props.pop(\"name\", None) or node_id\n\n        if all_batch_nodes.get(node_name):\n            # update existing batch node\n            batch_node = all_batch_nodes[node_name]\n        else:\n            # create new batch node\n            batch_node = batch_group.create_node(node_type)\n\n            # set name\n            batch_node.name.set_value(node_name)\n\n        # set attributes found in node props\n        for key, value in node_props.items():\n            if not hasattr(batch_node, key):\n                continue\n            setattr(batch_node, key, value)\n\n        # add created node for possible linking\n        all_batch_nodes[node_id] = batch_node\n\n    # link nodes to each other\n    for link in batch_links:\n        _from_n, _to_n = link[\"from_node\"], link[\"to_node\"]\n\n        # check if all linking nodes are available\n        if not all([\n            all_batch_nodes.get(_from_n[\"id\"]),\n            all_batch_nodes.get(_to_n[\"id\"])\n        ]):\n            continue\n\n        # link nodes in defined link\n        batch_group.connect_nodes(\n            all_batch_nodes[_from_n[\"id\"]], _from_n[\"connector\"],\n            all_batch_nodes[_to_n[\"id\"]], _to_n[\"connector\"]\n        )\n\n    # sort batch nodes\n    batch_group.organize()\n\n    return all_batch_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.create_segment_data_marker","title":"<code>create_segment_data_marker(segment)</code>","text":"<p>Create AYON marker on a segment.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <p>Returns:</p> Type Description <p>flame.PyMarker: flame api object</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def create_segment_data_marker(segment):\n    \"\"\" Create AYON marker on a segment.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n\n    Returns:\n        flame.PyMarker: flame api object\n    \"\"\"\n    # get duration of segment\n    duration = segment.record_duration.relative_frame\n    # calculate start frame of the new marker\n    start_frame = int(segment.record_in.relative_frame) + int(duration / 2)\n    # create marker\n    marker = segment.create_marker(start_frame)\n    # set marker name\n    marker.name = MARKER_NAME\n    # set duration\n    marker.duration = MARKER_DURATION\n    # set colour\n    marker.colour = COLOR_MAP[MARKER_COLOR]  # Red\n\n    return marker\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.export_clip","title":"<code>export_clip(export_path, clip, preset_path, **kwargs)</code>","text":"<p>Flame exported wrapper</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>str</code> <p>exporting directory path</p> required <code>clip</code> <code>PyClip</code> <p>flame api object</p> required <code>preset_path</code> <code>str</code> <p>full export path to xml file</p> required Kwargs <p>thumb_frame_number (int)[optional]: source frame number in_mark (int)[optional]: cut in mark out_mark (int)[optional]: cut out mark</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Missing input kwarg <code>thumb_frame_number</code>       in case <code>thumbnail</code> in <code>export_preset</code></p> <code>FileExistsError</code> <p>Missing export preset in shared folder</p> Source code in <code>client/ayon_flame/api/render_utils.py</code> <pre><code>def export_clip(export_path, clip, preset_path, **kwargs):\n    \"\"\"Flame exported wrapper\n\n    Args:\n        export_path (str): exporting directory path\n        clip (PyClip): flame api object\n        preset_path (str): full export path to xml file\n\n    Kwargs:\n        thumb_frame_number (int)[optional]: source frame number\n        in_mark (int)[optional]: cut in mark\n        out_mark (int)[optional]: cut out mark\n\n    Raises:\n        KeyError: Missing input kwarg `thumb_frame_number`\n                  in case `thumbnail` in `export_preset`\n        FileExistsError: Missing export preset in shared folder\n    \"\"\"\n    import flame\n\n    in_mark = out_mark = None\n\n    # Set exporter\n    exporter = flame.PyExporter()\n    exporter.foreground = True\n    exporter.export_between_marks = True\n\n    if kwargs.get(\"thumb_frame_number\"):\n        thumb_frame_number = kwargs[\"thumb_frame_number\"]\n        # make sure it exists in kwargs\n        if not thumb_frame_number:\n            raise KeyError(\n                \"Missing key `thumb_frame_number` in input kwargs\")\n\n        in_mark = int(thumb_frame_number)\n        out_mark = int(thumb_frame_number) + 1\n\n    elif kwargs.get(\"in_mark\") and kwargs.get(\"out_mark\"):\n        in_mark = int(kwargs[\"in_mark\"])\n        out_mark = int(kwargs[\"out_mark\"])\n    else:\n        exporter.export_between_marks = False\n\n    try:\n        # set in and out marks if they are available\n        if in_mark and out_mark:\n            clip.in_mark = in_mark\n            clip.out_mark = out_mark\n\n        # export with exporter\n        exporter.export(clip, preset_path, export_path)\n    finally:\n        print('Exported: {} at {}-{}'.format(\n            clip.name.get_value(),\n            clip.in_mark,\n            clip.out_mark\n        ))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_frame_from_filename","title":"<code>get_frame_from_filename(filename)</code>","text":"<p>Return sequence number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>sequence frame number</p> Example <p>def get_frame_from_filename(path):     (\"plate.0001.exr\") &gt; 0001</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_frame_from_filename(filename):\n    \"\"\"\n    Return sequence number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        int: sequence frame number\n\n    Example:\n        def get_frame_from_filename(path):\n            (\"plate.0001.exr\") &gt; 0001\n\n    \"\"\"\n\n    found = re.findall(FRAME_PATTERN, filename)\n\n    return found.pop() if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_padding_from_filename","title":"<code>get_padding_from_filename(filename)</code>","text":"<p>Return padding number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>padding number</p> Example <p>get_padding_from_filename(\"plate.0001.exr\") &gt; 4</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_padding_from_filename(filename):\n    \"\"\"\n    Return padding number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        int: padding number\n\n    Example:\n        get_padding_from_filename(\"plate.0001.exr\") &gt; 4\n\n    \"\"\"\n    found = get_frame_from_filename(filename)\n\n    return len(found) if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_publish_attribute","title":"<code>get_publish_attribute(segment)</code>","text":"<p>Get Publish attribute from input Tag object</p> Attribute <p>segment (flame.PySegment)): flame api object</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True or False</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_publish_attribute(segment):\n    \"\"\" Get Publish attribute from input Tag object\n\n    Attribute:\n        segment (flame.PySegment)): flame api object\n\n    Returns:\n        bool: True or False\n    \"\"\"\n    tag_data = get_segment_data_marker(segment)\n\n    if not tag_data:\n        set_publish_attribute(segment, MARKER_PUBLISH_DEFAULT)\n        return MARKER_PUBLISH_DEFAULT\n\n    return tag_data[\"active\"]\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_reformatted_filename","title":"<code>get_reformatted_filename(filename, padded=True)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_reformatted_filename(filename, padded=True):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    found = FRAME_PATTERN.search(filename)\n\n    if not found:\n        log.info(\"File name is not sequence: {}\".format(filename))\n        return filename\n\n    padding = get_padding_from_filename(filename)\n\n    replacement = \"%0{}d\".format(padding) if padded else \"%d\"\n    start_idx, end_idx = found.span(1)\n\n    return replacement.join(\n        [filename[:start_idx], filename[end_idx:]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_segment_attributes","title":"<code>get_segment_attributes(segment, validation_aggregator=None)</code>","text":"<p>Get attributes of a segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Segment</code> <p>Segment to get attributes from.</p> required <code>validation_aggregator</code> <code>ValidationAggregator</code> <pre><code>Output object to store attributes for passing into\npublishing validation. Defaults to None.\n</code></pre> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of attributes.</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_segment_attributes(\n    segment, validation_aggregator: ValidationAggregator = None):\n    \"\"\"Get attributes of a segment.\n\n    Args:\n        segment (Segment): Segment to get attributes from.\n        validation_aggregator (ValidationAggregator, optional):\n                Output object to store attributes for passing into\n                publishing validation. Defaults to None.\n\n    Returns:\n        dict: Dictionary of attributes.\n    \"\"\"\n    if segment.type == \"Gap\":\n        return None\n\n    if not validation_aggregator:\n        validation_aggregator = ValidationAggregator()\n\n    segment_name = segment.name.get_value()\n\n    # Add timeline segment to tree\n    clip_data = {\n        \"shot_name\": segment.shot_name.get_value(),\n        \"segment_comment\": segment.comment.get_value(),\n        \"tape_name\": segment.tape_name,\n        \"source_name\": segment.source_name,\n        \"PySegment\": segment,\n    }\n    # make sure even segments without proper name are handled as missing\n    # this way they will be detected by Publisher Validator\n    if not segment_name:\n        clip_data[\"segment_name\"] = \"Missing: Segment's Name\"\n        if segment not in validation_aggregator.failed_segments:\n            validation_aggregator.failed_segments.append(segment)\n    else:\n        clip_data[\"segment_name\"] = segment_name\n\n    # make sure even segments without file path are handled as missing\n    # this way they will be detected by Publisher Validator\n    if segment.file_path and segment_name:\n        clip_data[\"fpath\"] = segment.file_path\n    else:\n        clip_data[\"segment_name\"] = \"Missing: Segment's File Path\"\n        if segment not in validation_aggregator.failed_segments:\n            validation_aggregator.failed_segments.append(segment)\n\n    # head and tail with forward compatibility\n    if segment.head:\n        # `infinite` can be also returned\n        if isinstance(segment.head, str):\n            clip_data[\"segment_head\"] = 0\n        else:\n            clip_data[\"segment_head\"] = int(segment.head)\n    if segment.tail:\n        # `infinite` can be also returned\n        if isinstance(segment.tail, str):\n            clip_data[\"segment_tail\"] = 0\n        else:\n            clip_data[\"segment_tail\"] = int(segment.tail)\n\n    # add all available shot tokens\n    shot_tokens = _get_shot_tokens_values(segment, [\n        \"&lt;colour space&gt;\", \"&lt;width&gt;\", \"&lt;height&gt;\", \"&lt;depth&gt;\", \"&lt;segment&gt;\",\n        \"&lt;track&gt;\", \"&lt;track name&gt;\"\n    ])\n    clip_data.update(shot_tokens)\n\n    # populate shot source metadata\n    segment_attrs = [\n        \"record_duration\", \"record_in\", \"record_out\",\n        \"source_in\", \"source_out\", \"source_frame_rate\", \"source_height\",\n        \"source_width\", \"source_ratio\", \"start_frame\", \"head\", \"tail\",\n    ]\n    segment_attrs_data = {}\n    for attr_name in segment_attrs:\n        if not hasattr(segment, attr_name):\n            continue\n        attr = getattr(segment, attr_name)\n        segment_attrs_data[attr_name] = str(attr).replace(\"+\", \":\")\n\n        if attr_name in [\"record_in\", \"record_out\"]:\n            clip_data[attr_name] = attr.relative_frame\n        else:\n            if hasattr(attr, \"frame\"):\n                clip_data[attr_name] = attr.frame\n\n    clip_data[\"segment_timecodes\"] = segment_attrs_data\n    return clip_data\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.get_segment_data_marker","title":"<code>get_segment_data_marker(segment, with_marker=None)</code>","text":"<p>Get AYON track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <code>with_marker</code> <code>bool)[optional]</code> <p>if true it will return also marker object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>AYON tag data</p> <p>Returns(with_marker=True):     flame.PyMarker, dict</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_segment_data_marker(segment, with_marker=None):\n    \"\"\"\n    Get AYON track item tag created by creator or loader plugin.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n        with_marker (bool)[optional]: if true it will return also marker object\n\n    Returns:\n        dict: AYON tag data\n\n    Returns(with_marker=True):\n        flame.PyMarker, dict\n    \"\"\"\n    for marker in segment.markers:\n        comment = marker.comment.get_value()\n        color = marker.colour.get_value()\n        name = marker.name.get_value()\n\n        if (name == MARKER_NAME) and (\n                color == COLOR_MAP[MARKER_COLOR]):\n            if not with_marker:\n                return json.loads(comment)\n            else:\n                return marker, json.loads(comment)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.imprint","title":"<code>imprint(segment, data=None)</code>","text":"<p>Adding AYON data to Flame timeline segment.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>flame.PySegment)</code> <p>flame api object</p> required <code>data</code> <code>dict</code> <p>Any data which needst to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'asset': 'sq020sh0280',     'productType': 'render',     'productName': 'productMain' }</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def imprint(segment, data=None):\n    \"\"\"\n    Adding AYON data to Flame timeline segment.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        segment (flame.PySegment)): flame api object\n        data (dict): Any data which needst to be imprinted\n\n    Examples:\n        data = {\n            'asset': 'sq020sh0280',\n            'productType': 'render',\n            'productName': 'productMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_segment_data_marker(segment, data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def list_instances():\n    \"\"\"List all created instances from current workfile.\"\"\"\n    # TODO: list_instances\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.maintained_object_duplication","title":"<code>maintained_object_duplication(item)</code>","text":"<p>Maintain input item duplication</p> <p>Attributes:</p> Name Type Description <code>item</code> <code>any flame.PyObject</code> <p>python api object</p> Yield <p>duplicate input PyObject type</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_object_duplication(item):\n    \"\"\"Maintain input item duplication\n\n    Attributes:\n        item (any flame.PyObject): python api object\n\n    Yield:\n        duplicate input PyObject type\n    \"\"\"\n    import flame\n    # Duplicate the clip to avoid modifying the original clip\n    duplicate = flame.duplicate(item)\n\n    try:\n        # do the operation on selected segments\n        yield duplicate\n    finally:\n        # delete the item at the end\n        flame.delete(duplicate)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.maintained_segment_selection","title":"<code>maintained_segment_selection(sequence)</code>","text":"<p>Maintain selection during context</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>PySequence</code> <p>python api object</p> Yield <p>list of flame.PySegment</p> Example <p>with maintained_segment_selection(sequence) as selected_segments: ...     for segment in selected_segments: ...         segment.selected = False print(segment.selected) True</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_segment_selection(sequence):\n    \"\"\"Maintain selection during context\n\n    Attributes:\n        sequence (flame.PySequence): python api object\n\n    Yield:\n        list of flame.PySegment\n\n    Example:\n        &gt;&gt;&gt; with maintained_segment_selection(sequence) as selected_segments:\n        ...     for segment in selected_segments:\n        ...         segment.selected = False\n        &gt;&gt;&gt; print(segment.selected)\n        True\n    \"\"\"\n    selected_segments = get_sequence_segments(sequence, True)\n    try:\n        # do the operation on selected segments\n        yield selected_segments\n    finally:\n        # reset all selected clips\n        reset_segment_selection(sequence)\n        # select only original selection of segments\n        for segment in selected_segments:\n            segment.selected = True\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.modify_preset_file","title":"<code>modify_preset_file(xml_path, staging_dir, data)</code>","text":"<p>Modify xml preset with input data</p> <p>Parameters:</p> Name Type Description Default <code>xml_path</code> <code>str</code> <p>path for input xml preset</p> required <code>staging_dir</code> <code>str</code> <p>staging dir path</p> required <code>data</code> <code>dict</code> <p>data where key is xmlTag and value as string</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>description</p> Source code in <code>client/ayon_flame/api/render_utils.py</code> <pre><code>def modify_preset_file(xml_path, staging_dir, data):\n    \"\"\"Modify xml preset with input data\n\n    Args:\n        xml_path (str ): path for input xml preset\n        staging_dir (str): staging dir path\n        data (dict): data where key is xmlTag and value as string\n\n    Returns:\n        str: _description_\n    \"\"\"\n    # create temp path\n    dirname, basename = os.path.split(xml_path)\n    temp_path = os.path.join(staging_dir, basename)\n\n    # change xml following data keys\n    with open(xml_path, \"r\") as datafile:\n        _root = ET.parse(datafile)\n\n        for key, value in data.items():\n            try:\n                if \"/\" in key:\n                    if not key.startswith(\"./\"):\n                        key = \".//\" + key\n\n                    split_key_path = key.split(\"/\")\n                    element_key = split_key_path[-1]\n                    parent_obj_path = \"/\".join(split_key_path[:-1])\n\n                    parent_obj = _root.find(parent_obj_path)\n                    element_obj = parent_obj.find(element_key)\n                    if not element_obj:\n                        append_element(parent_obj, element_key, value)\n                else:\n                    finds = _root.findall(\".//{}\".format(key))\n                    if not finds:\n                        raise AttributeError\n                    for element in finds:\n                        element.text = str(value)\n            except AttributeError:\n                log.warning(\n                    \"Cannot create attribute: {}: {}. Skipping\".format(\n                        key, value\n                    ))\n        _root.write(temp_path)\n\n    return temp_path\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance marker from track item.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def remove_instance(instance):\n    \"\"\"Remove instance marker from track item.\"\"\"\n    # TODO: remove_instance\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.reset_segment_selection","title":"<code>reset_segment_selection(sequence)</code>","text":"<p>Deselect all selected nodes</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def reset_segment_selection(sequence):\n    \"\"\"Deselect all selected nodes\n    \"\"\"\n    for ver in sequence.versions:\n        for track in ver.tracks:\n            if len(track.segments) == 0 and track.hidden:\n                continue\n            for segment in track.segments:\n                segment.selected = False\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.set_publish_attribute","title":"<code>set_publish_attribute(segment, value)</code>","text":"<p>Set Publish attribute in input Tag object</p> Attribute <p>segment (flame.PySegment)): flame api object value (bool): True or False</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def set_publish_attribute(segment, value):\n    \"\"\" Set Publish attribute in input Tag object\n\n    Attribute:\n        segment (flame.PySegment)): flame api object\n        value (bool): True or False\n    \"\"\"\n    tag_data = get_segment_data_marker(segment)\n    tag_data[\"active\"] = value\n\n    # set data to the active attribute\n    set_segment_data_marker(segment, tag_data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.set_segment_data_marker","title":"<code>set_segment_data_marker(segment, data=None)</code>","text":"<p>Set AYON track item tag to input segment.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>json loaded data</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def set_segment_data_marker(segment, data=None):\n    \"\"\"\n    Set AYON track item tag to input segment.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n\n    Returns:\n        dict: json loaded data\n    \"\"\"\n    data = data or dict()\n\n    marker_data = get_segment_data_marker(segment, True)\n\n    if marker_data:\n        # get available AYON tag if any\n        marker, tag_data = marker_data\n        # update tag data with new data\n        tag_data.update(data)\n        # update marker with tag data\n        marker.comment = json.dumps(tag_data)\n    else:\n        # update tag data with new data\n        marker = create_segment_data_marker(segment)\n        # add tag data to marker's comment\n        marker.comment = json.dumps(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.setup","title":"<code>setup(env=None)</code>","text":"<p>Wrapper installer started from <code>flame/hooks/pre_flame_setup.py</code></p> Source code in <code>client/ayon_flame/api/utils.py</code> <pre><code>def setup(env=None):\n    \"\"\" Wrapper installer started from\n    `flame/hooks/pre_flame_setup.py`\n    \"\"\"\n    env = env or os.environ\n\n    # synchronize resolve utility scripts\n    _sync_utility_scripts(env)\n\n    log.info(\"Flame AYON wrapper has been installed\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/index.html#client.ayon_flame.api.update_container","title":"<code>update_container(tl_segment, data=None)</code>","text":"<p>Update container data to input timeline_item's AYON tag.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def update_container(tl_segment, data=None):\n    \"\"\"Update container data to input timeline_item's AYON tag.\n    \"\"\"\n    # TODO: update_container\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/batch_utils.html","title":"batch_utils","text":""},{"location":"autoapi/client/ayon_flame/api/batch_utils.html#client.ayon_flame.api.batch_utils.create_batch_group","title":"<code>create_batch_group(name, frame_start, frame_duration, update_batch_group=None, **kwargs)</code>","text":"<p>Create Batch Group in active project's Desktop</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of batch group to be created</p> required <code>frame_start</code> <code>int</code> <p>start frame of batch</p> required <code>frame_end</code> <code>int</code> <p>end frame of batch</p> required <code>update_batch_group (PyBatch)[optional]</code> <p>batch group to update</p> required Return <p>PyBatch: active flame batch group</p> Source code in <code>client/ayon_flame/api/batch_utils.py</code> <pre><code>def create_batch_group(\n    name,\n    frame_start,\n    frame_duration,\n    update_batch_group=None,\n    **kwargs\n):\n    \"\"\"Create Batch Group in active project's Desktop\n\n    Args:\n        name (str): name of batch group to be created\n        frame_start (int): start frame of batch\n        frame_end (int): end frame of batch\n        update_batch_group (PyBatch)[optional]: batch group to update\n\n    Return:\n        PyBatch: active flame batch group\n    \"\"\"\n    # make sure some batch obj is present\n    batch_group = update_batch_group or flame.batch\n\n    schematic_reels = kwargs.get(\"shematic_reels\") or ['LoadedReel1']\n    shelf_reels = kwargs.get(\"shelf_reels\") or ['ShelfReel1']\n\n    handle_start = kwargs.get(\"handleStart\") or 0\n    handle_end = kwargs.get(\"handleEnd\") or 0\n\n    frame_start -= handle_start\n    frame_duration += handle_start + handle_end\n\n    if not update_batch_group:\n        # Create batch group with name, start_frame value, duration value,\n        # set of schematic reel names, set of shelf reel names\n        batch_group = batch_group.create_batch_group(\n            name,\n            start_frame=frame_start,\n            duration=frame_duration,\n            reels=schematic_reels,\n            shelf_reels=shelf_reels\n        )\n    else:\n        batch_group.name = name\n        batch_group.start_frame = frame_start\n        batch_group.duration = frame_duration\n\n        # add reels to batch group\n        _add_reels_to_batch_group(\n            batch_group, schematic_reels, shelf_reels)\n\n        # TODO: also update write node if there is any\n        # TODO: also update loaders to start from correct frameStart\n\n    if kwargs.get(\"switch_batch_tab\"):\n        # use this command to switch to the batch tab\n        batch_group.go_to()\n\n    return batch_group\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/batch_utils.html#client.ayon_flame.api.batch_utils.create_batch_group_conent","title":"<code>create_batch_group_conent(batch_nodes, batch_links, batch_group=None)</code>","text":"<p>Creating batch group with links</p> <p>Parameters:</p> Name Type Description Default <code>batch_nodes</code> <code>list of dict</code> <p>each dict is node definition</p> required <code>batch_links</code> <code>list of dict</code> <p>each dict is link definition</p> required <code>batch_group</code> <code>PyBatch</code> <p>batch group. Defaults to None.</p> <code>None</code> Return <p>dict: all batch nodes {name or id: PyNode}</p> Source code in <code>client/ayon_flame/api/batch_utils.py</code> <pre><code>def create_batch_group_conent(batch_nodes, batch_links, batch_group=None):\n    \"\"\"Creating batch group with links\n\n    Args:\n        batch_nodes (list of dict): each dict is node definition\n        batch_links (list of dict): each dict is link definition\n        batch_group (PyBatch, optional): batch group. Defaults to None.\n\n    Return:\n        dict: all batch nodes {name or id: PyNode}\n    \"\"\"\n    # make sure some batch obj is present\n    batch_group = batch_group or flame.batch\n    all_batch_nodes = {\n        b.name.get_value(): b\n        for b in batch_group.nodes\n    }\n    for node in batch_nodes:\n        # NOTE: node_props needs to be ideally OrederDict type\n        node_id, node_type, node_props = (\n            node[\"id\"], node[\"type\"], node[\"properties\"])\n\n        # get node name for checking if exists\n        node_name = node_props.pop(\"name\", None) or node_id\n\n        if all_batch_nodes.get(node_name):\n            # update existing batch node\n            batch_node = all_batch_nodes[node_name]\n        else:\n            # create new batch node\n            batch_node = batch_group.create_node(node_type)\n\n            # set name\n            batch_node.name.set_value(node_name)\n\n        # set attributes found in node props\n        for key, value in node_props.items():\n            if not hasattr(batch_node, key):\n                continue\n            setattr(batch_node, key, value)\n\n        # add created node for possible linking\n        all_batch_nodes[node_id] = batch_node\n\n    # link nodes to each other\n    for link in batch_links:\n        _from_n, _to_n = link[\"from_node\"], link[\"to_node\"]\n\n        # check if all linking nodes are available\n        if not all([\n            all_batch_nodes.get(_from_n[\"id\"]),\n            all_batch_nodes.get(_to_n[\"id\"])\n        ]):\n            continue\n\n        # link nodes in defined link\n        batch_group.connect_nodes(\n            all_batch_nodes[_from_n[\"id\"]], _from_n[\"connector\"],\n            all_batch_nodes[_to_n[\"id\"]], _to_n[\"connector\"]\n        )\n\n    # sort batch nodes\n    batch_group.organize()\n\n    return all_batch_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/constants.html","title":"constants","text":"<p>AYON Flame api constances</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile","title":"<code>MediaInfoFile</code>","text":"<p>               Bases: <code>object</code></p> <p>Class to get media info file clip data</p> <p>Raises:</p> Type Description <code>IOError</code> <p>MEDIA_SCRIPT_PATH path doesn't exists</p> <code>TypeError</code> <p>Not able to generate clip xml data file</p> <code>ParseError</code> <p>Missing clip in xml clip data</p> <code>IOError</code> <p>Not able to save xml clip data to file</p> <p>Attributes:</p> Name Type Description <code>str</code> <p><code>MEDIA_SCRIPT_PATH</code> path to flame binary</p> <code>logging.Logger</code> <p><code>log</code> logger</p> <p>TODO: add method for getting metadata to dict</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>class MediaInfoFile(object):\n    \"\"\"Class to get media info file clip data\n\n    Raises:\n        IOError: MEDIA_SCRIPT_PATH path doesn't exists\n        TypeError: Not able to generate clip xml data file\n        ET.ParseError: Missing clip in xml clip data\n        IOError: Not able to save xml clip data to file\n\n    Attributes:\n        str: `MEDIA_SCRIPT_PATH` path to flame binary\n        logging.Logger: `log` logger\n\n    TODO: add method for getting metadata to dict\n    \"\"\"\n    MEDIA_SCRIPT_PATH = \"/opt/Autodesk/mio/current/dl_get_media_info\"\n\n    log = log\n\n    _clip_data = None\n    _start_frame = None\n    _fps = None\n    _drop_mode = None\n    _file_pattern = None\n\n    def __init__(self, path, logger=None):\n\n        # replace log if any\n        if logger:\n            self.log = logger\n\n        # test if `dl_get_media_info` path exists\n        self._validate_media_script_path()\n\n        # derivate other feed variables\n        feed_basename = os.path.basename(path)\n        feed_dir = os.path.dirname(path)\n        feed_ext = os.path.splitext(feed_basename)[1][1:].lower()\n\n        with maintained_temp_file_path(\".clip\") as tmp_path:\n            self.log.info(\"Temp File: {}\".format(tmp_path))\n            self._generate_media_info_file(tmp_path, feed_ext, feed_dir)\n\n            # get collection containing feed_basename from path\n            self.file_pattern = self._get_collection(\n                feed_basename, feed_dir, feed_ext)\n\n            if (\n                not self.file_pattern\n                and os.path.exists(os.path.join(feed_dir, feed_basename))\n            ):\n                self.file_pattern = feed_basename\n\n            # get clip data and make them single if there is multiple\n            # clips data\n            xml_data = self._make_single_clip_media_info(\n                tmp_path, feed_basename, self.file_pattern)\n            self.log.debug(\"xml_data: {}\".format(xml_data))\n            self.log.debug(\"type: {}\".format(type(xml_data)))\n\n            # get all time related data and assign them\n            self._get_time_info_from_origin(xml_data)\n            self.log.debug(\"start_frame: {}\".format(self.start_frame))\n            self.log.debug(\"fps: {}\".format(self.fps))\n            self.log.debug(\"drop frame: {}\".format(self.drop_mode))\n            # get all resolution related data and assign them\n            self._get_resolution_info_from_origin(xml_data)\n\n            try:\n                self.log.debug(\"width: {}\".format(self.width))\n                self.log.debug(\"height: {}\".format(self.height))\n                self.log.debug(\"pixel aspect: {}\".format(self.pixel_aspect))\n\n            except AttributeError:\n                self.log.debug(\"audio: true\")\n\n            self.clip_data = xml_data\n\n    def _get_typed_value(self, xml_obj):\n        \"\"\" Get typed value from xml object\n\n        Args:\n            xml_obj (xml.etree.ElementTree.Element): xml object\n\n        Returns:\n            str: value\n        \"\"\"\n        if hasattr(xml_obj, \"type\"):\n            if xml_obj.type in [\"int\", \"uint\"]:\n                return int(xml_obj.text)\n            if xml_obj.type == \"float\":\n                return float(xml_obj.text)\n            if xml_obj.type == \"string\":\n                return str(xml_obj.text)\n\n        return xml_obj.text\n\n    def _get_collection(self, feed_basename, feed_dir, feed_ext) -&gt; str | None:\n        \"\"\"Get collection string.\n\n        Args:\n            feed_basename (str): file base name\n            feed_dir (str): file's directory\n            feed_ext (str): file extension\n\n        Raises:\n            AttributeError: feed_ext is not matching feed_basename\n\n        Returns:\n            str: collection basename with range of sequence\n        \"\"\"\n        partialname = self._separate_file_head(feed_basename, feed_ext)\n\n        # make sure partial input basename is having correct extensoon\n        if not partialname:\n            raise AttributeError(\n                f\"Wrong input attributes. Basename - {feed_basename}, \"\n                f\"Ext - {feed_ext}\"\n            )\n\n        # get all related files\n        files = [\n            f for f in os.listdir(feed_dir)\n            if partialname == self._separate_file_head(f, feed_ext)\n        ]\n\n        # ignore reminders as we dont need them\n        collections = clique.assemble(files)[0]\n\n        # in case no collection found return None\n        # it is probably just single file\n        if not collections:\n            return\n\n        # we expect only one collection\n        collection = collections[0]\n\n        self.log.debug(\"__ collection: {}\".format(collection))\n\n        if collection.is_contiguous():\n            return self._format_collection(collection)\n\n        # add `[` in front to make sure it want capture\n        # shot name with the same number\n        number_from_path = self._separate_number(feed_basename, feed_ext)\n        search_number_pattern = \"[\" + number_from_path\n        # convert to multiple collections\n        _continues_colls = collection.separate()\n        for _coll in _continues_colls:\n            coll_to_text = self._format_collection(\n                _coll, len(number_from_path))\n            self.log.debug(\"__ coll_to_text: {}\".format(coll_to_text))\n            if search_number_pattern in coll_to_text:\n                return coll_to_text\n        return None\n\n    @staticmethod\n    def _format_collection(collection, padding=None):\n        padding = padding or collection.padding\n        # if no holes then return collection\n        head = collection.format(\"{head}\")\n        tail = collection.format(\"{tail}\")\n        range_template = \"[{{:0{0}d}}-{{:0{0}d}}]\".format(\n            padding)\n        ranges = range_template.format(\n            min(collection.indexes),\n            max(collection.indexes)\n        )\n        # if no holes then return collection\n        return \"{}{}{}\".format(head, ranges, tail)\n\n    def _separate_file_head(self, basename, extension):\n        \"\"\" Get only head with out sequence and extension\n\n        Args:\n            basename (str): file base name\n            extension (str): file extension\n\n        Returns:\n            str: file head\n        \"\"\"\n        # in case sequence file\n        found = re.findall(\n            r\"(.*)[._][\\d]*(?=.{})\".format(extension),\n            basename,\n        )\n        if found:\n            return found.pop()\n\n        # in case single file\n        name, ext = os.path.splitext(basename)\n\n        if extension == ext[1:]:\n            return name\n\n    def _separate_number(self, basename, extension):\n        \"\"\" Get only sequence number as string\n\n        Args:\n            basename (str): file base name\n            extension (str): file extension\n\n        Returns:\n            str: number with padding\n        \"\"\"\n        # in case sequence file\n        found = re.findall(\n            r\"[._]([\\d]*)(?=.{})\".format(extension),\n            basename,\n        )\n        if found:\n            return found.pop()\n\n    @property\n    def clip_data(self):\n        \"\"\"Clip's xml clip data\n\n        Returns:\n            xml.etree.ElementTree: xml data\n        \"\"\"\n        return self._clip_data\n\n    @clip_data.setter\n    def clip_data(self, data):\n        self._clip_data = data\n\n    @property\n    def start_frame(self):\n        \"\"\" Clip's starting frame found in timecode\n\n        Returns:\n            int: number of frames\n        \"\"\"\n        return self._start_frame\n\n    @start_frame.setter\n    def start_frame(self, number):\n        self._start_frame = int(number)\n\n    @property\n    def fps(self):\n        \"\"\" Clip's frame rate\n\n        Returns:\n            float: frame rate\n        \"\"\"\n        return self._fps\n\n    @fps.setter\n    def fps(self, fl_number):\n        self._fps = float(fl_number)\n\n    @property\n    def drop_mode(self):\n        \"\"\" Clip's drop frame mode\n\n        Returns:\n            str: drop frame flag\n        \"\"\"\n        return self._drop_mode\n\n    @drop_mode.setter\n    def drop_mode(self, text):\n        self._drop_mode = str(text)\n\n    @property\n    def file_pattern(self):\n        \"\"\"Clips file pattern.\n\n        Returns:\n            str: file pattern. ex. file.[1-2].exr\n        \"\"\"\n        return self._file_pattern\n\n    @file_pattern.setter\n    def file_pattern(self, fpattern):\n        self._file_pattern = fpattern\n\n    def _validate_media_script_path(self):\n        if not os.path.isfile(self.MEDIA_SCRIPT_PATH):\n            raise IOError(\"Media Script does not exist: `{}`\".format(\n                self.MEDIA_SCRIPT_PATH))\n\n    def _generate_media_info_file(self, fpath, feed_ext, feed_dir):\n        \"\"\" Generate media info xml .clip file\n\n        Args:\n            fpath (str): .clip file path\n            feed_ext (str): file extension to be filtered\n            feed_dir (str): look up directory\n\n        Raises:\n            TypeError: Type error if it fails\n        \"\"\"\n        # Create cmd arguments for gettig xml file info file\n        cmd_args = [\n            self.MEDIA_SCRIPT_PATH,\n            \"-e\", feed_ext,\n            \"-o\", fpath,\n            feed_dir\n        ]\n\n        try:\n            # execute creation of clip xml template data\n            run_subprocess(cmd_args)\n        except TypeError as error:\n            raise TypeError(\n                \"Error creating `{}` due: {}\".format(fpath, error))\n\n    def _make_single_clip_media_info(self, fpath, feed_basename, path_pattern):\n        \"\"\" Separate only relative clip object form .clip file\n\n        Args:\n            fpath (str): clip file path\n            feed_basename (str): search basename\n            path_pattern (str): search file pattern (file.[1-2].exr)\n\n        Raises:\n            ET.ParseError: if nothing found\n\n        Returns:\n            ET.Element: xml element data of matching clip\n        \"\"\"\n        with open(fpath) as f:\n            lines = f.readlines()\n            _added_root = itertools.chain(\n                \"&lt;root&gt;\", deepcopy(lines)[1:], \"&lt;/root&gt;\")\n            new_root = ET.fromstringlist(_added_root)\n\n        # find the clip which is matching to my input name\n        xml_clips = new_root.findall(\"clip\")\n        matching_clip = None\n        for xml_clip in xml_clips:\n            clip_name = xml_clip.find(\"name\").text\n            self.log.debug(\"__ clip_name: `{}`\".format(clip_name))\n            if clip_name not in feed_basename:\n                continue\n\n            # test path pattern\n            for out_track in xml_clip.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    for span in out_feed.iter(\"span\"):\n                        # start frame\n                        span_path = span.find(\"path\")\n                        self.log.debug(\n                            \"__ span_path.text: {}, path_pattern: {}\".format(\n                                span_path.text, path_pattern\n                            )\n                        )\n                        if path_pattern in span_path.text:\n                            matching_clip = xml_clip\n\n        if matching_clip is None:\n            # return warning there is missing clip\n            raise ET.ParseError(\n                \"Missing clip in `{}`. Available clips {}\".format(\n                    feed_basename, [\n                        xml_clip.find(\"name\").text\n                        for xml_clip in xml_clips\n                    ]\n                ))\n\n        return matching_clip\n\n    def _get_time_info_from_origin(self, xml_data):\n        \"\"\"Set time info to class attributes\n\n        Args:\n            xml_data (ET.Element): clip data\n        \"\"\"\n        try:\n            for out_track in xml_data.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    # start frame\n                    out_feed_nb_ticks_obj = out_feed.find(\n                        \"startTimecode/nbTicks\")\n                    self.start_frame = self._get_typed_value(\n                        out_feed_nb_ticks_obj)\n\n                    # fps\n                    out_feed_fps_obj = out_feed.find(\n                        \"startTimecode/rate\")\n                    self.fps = self._get_typed_value(out_feed_fps_obj)\n\n                    # drop frame mode\n                    out_feed_drop_mode_obj = out_feed.find(\n                        \"startTimecode/dropMode\")\n                    self.drop_mode = self._get_typed_value(\n                        out_feed_drop_mode_obj)\n                    break\n        except Exception as msg:\n            self.log.warning(msg)\n\n    def _get_resolution_info_from_origin(self, xml_data):\n        \"\"\"Set resolution info to class attributes\n\n        Args:\n            xml_data (ET.Element): clip data\n        \"\"\"\n        try:\n            for out_track in xml_data.iter(\"track\"):\n                for out_feed in out_track.iter(\"feed\"):\n                    # width\n                    out_feed_width_obj = out_feed.find(\"storageFormat/width\")\n                    self.width = int(self._get_typed_value(out_feed_width_obj))\n\n                    # height\n                    out_feed_height_obj = out_feed.find(\"storageFormat/height\")\n                    self.height = int(\n                        self._get_typed_value(out_feed_height_obj))\n\n                    # pixel aspect ratio\n                    out_feed_pixel_aspect_obj = out_feed.find(\n                        \"storageFormat/pixelRatio\")\n                    self.pixel_aspect = float(\n                        self._get_typed_value(out_feed_pixel_aspect_obj))\n                    break\n        except Exception as msg:\n            self.log.warning(msg)\n\n    @staticmethod\n    def write_clip_data_to_file(fpath, xml_element_data):\n        \"\"\" Write xml element of clip data to file\n\n        Args:\n            fpath (string): file path\n            xml_element_data (xml.etree.ElementTree.Element): xml data\n\n        Raises:\n            IOError: If data could not be written to file\n        \"\"\"\n        try:\n            # save it as new file\n            tree = cET.ElementTree(xml_element_data)\n            tree.write(\n                fpath, xml_declaration=True,\n                method=\"xml\", encoding=\"UTF-8\"\n            )\n        except IOError as error:\n            raise IOError(\n                \"Not able to write data to file: {}\".format(error))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.clip_data","title":"<code>clip_data</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's xml clip data</p> <p>Returns:</p> Type Description <p>xml.etree.ElementTree: xml data</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.drop_mode","title":"<code>drop_mode</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's drop frame mode</p> <p>Returns:</p> Name Type Description <code>str</code> <p>drop frame flag</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.file_pattern","title":"<code>file_pattern</code>  <code>property</code> <code>writable</code>","text":"<p>Clips file pattern.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>file pattern. ex. file.[1-2].exr</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.fps","title":"<code>fps</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's frame rate</p> <p>Returns:</p> Name Type Description <code>float</code> <p>frame rate</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.start_frame","title":"<code>start_frame</code>  <code>property</code> <code>writable</code>","text":"<p>Clip's starting frame found in timecode</p> <p>Returns:</p> Name Type Description <code>int</code> <p>number of frames</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.MediaInfoFile.write_clip_data_to_file","title":"<code>write_clip_data_to_file(fpath, xml_element_data)</code>  <code>staticmethod</code>","text":"<p>Write xml element of clip data to file</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>string</code> <p>file path</p> required <code>xml_element_data</code> <code>Element</code> <p>xml data</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If data could not be written to file</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@staticmethod\ndef write_clip_data_to_file(fpath, xml_element_data):\n    \"\"\" Write xml element of clip data to file\n\n    Args:\n        fpath (string): file path\n        xml_element_data (xml.etree.ElementTree.Element): xml data\n\n    Raises:\n        IOError: If data could not be written to file\n    \"\"\"\n    try:\n        # save it as new file\n        tree = cET.ElementTree(xml_element_data)\n        tree.write(\n            fpath, xml_declaration=True,\n            method=\"xml\", encoding=\"UTF-8\"\n        )\n    except IOError as error:\n        raise IOError(\n            \"Not able to write data to file: {}\".format(error))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.TimeEffectMetadata","title":"<code>TimeEffectMetadata</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>class TimeEffectMetadata(object):\n    log = log\n    _data = {}\n    _retime_modes = {\n        0: \"speed\",\n        1: \"timewarp\",\n        2: \"duration\"\n    }\n\n    def __init__(self, segment, logger=None):\n        if logger:\n            self.log = logger\n\n        self._setup_data, self._data = self._get_metadata(segment)\n\n    @property\n    def is_empty(self):\n        \"\"\" Returns either the current object is empty or not.\n\n        Returns:\n            bool. Is the TimeEffectMetadata object empty?\n        \"\"\"\n        return self._setup_data is None\n\n    @property\n    def data(self):\n        \"\"\" Returns timewarp effect data\n\n        Returns:\n            dict: retime data\n        \"\"\"\n        return self._data\n\n    @property\n    def setup_data(self):\n        \"\"\" Returns timewarp effect setup data\n\n        Returns:\n            str. The XML formatted setup data.\n        \"\"\"\n        return self._setup_data\n\n    def _get_metadata(self, segment):\n        effects = segment.effects or []\n        for effect in effects:\n            if effect.type == \"Timewarp\":\n                with maintained_temp_file_path(\".timewarp_node\") as tmp_path:\n                    self.log.info(\"Temp File: {}\".format(tmp_path))\n                    effect.save_setup(tmp_path)\n                    return self._get_attributes_from_xml(tmp_path)\n\n        return None, {}\n\n    def _get_attributes_from_xml(self, tmp_path):\n        with open(tmp_path, \"r\") as tw_setup_file:\n            tw_setup_string = tw_setup_file.read()\n            tw_setup_file.close()\n\n        tw_setup_xml = ET.fromstring(tw_setup_string)\n        tw_setup = self._dictify(tw_setup_xml)\n        # pprint(tw_setup)\n        try:\n            tw_setup_state = tw_setup[\"Setup\"][\"State\"][0]\n            mode = int(\n                tw_setup_state[\"TW_RetimerMode\"][0][\"_text\"]\n            )\n            r_data = {\n                \"type\": self._retime_modes[mode],\n                \"effectStart\": int(\n                    tw_setup[\"Setup\"][\"Base\"][0][\"Range\"][0][\"Start\"]),\n                \"effectEnd\": int(\n                    tw_setup[\"Setup\"][\"Base\"][0][\"Range\"][0][\"End\"])\n            }\n\n            if mode == 0:  # speed\n                r_data[self._retime_modes[mode]] = float(\n                    tw_setup_state[\"TW_Speed\"]\n                    [0][\"Channel\"][0][\"Value\"][0][\"_text\"]\n                ) / 100\n                r_data[\"numKeys\"] = int(\n                    tw_setup_state[\"TW_SpeedTiming\"]\n                    [0][\"Channel\"][0][\"Size\"][0][\"_text\"]\n                )\n            elif mode == 1:  # timewarp\n                r_data[self._retime_modes[mode]] = self._get_anim_keys(\n                    tw_setup_state[\"TW_Timing\"]\n                )\n            elif mode == 2:  # duration\n                r_data[self._retime_modes[mode]] = {\n                    \"start\": {\n                        \"source\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][0][\"Value\"][0][\"_text\"]\n                        ),\n                        \"timeline\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][0][\"Frame\"][0][\"_text\"]\n                        )\n                    },\n                    \"end\": {\n                        \"source\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][1][\"Value\"][0][\"_text\"]\n                        ),\n                        \"timeline\": int(\n                            tw_setup_state[\"TW_DurationTiming\"][0][\"Channel\"]\n                            [0][\"KFrames\"][0][\"Key\"][1][\"Frame\"][0][\"_text\"]\n                        )\n                    }\n                }\n        except Exception:\n            lines = traceback.format_exception(*sys.exc_info())\n            self.log.error(\"\\n\".join(lines))\n            return None, {}\n\n        return tw_setup_string, r_data\n\n    def _get_anim_keys(self, setup_cat, index=None):\n        return_data = {\n            \"extrapolation\": (\n                setup_cat[0][\"Channel\"][0][\"Extrap\"][0][\"_text\"]\n            ),\n            \"animKeys\": []\n        }\n        for key in setup_cat[0][\"Channel\"][0][\"KFrames\"][0][\"Key\"]:\n            if index and int(key[\"Index\"]) != index:\n                continue\n            key_data = {\n                \"source\": float(key[\"Value\"][0][\"_text\"]),\n                \"timeline\": float(key[\"Frame\"][0][\"_text\"]),\n                \"index\": int(key[\"Index\"]),\n                \"curveMode\": key[\"CurveMode\"][0][\"_text\"],\n                \"curveOrder\": key[\"CurveOrder\"][0][\"_text\"]\n            }\n            if key.get(\"TangentMode\"):\n                key_data[\"tangentMode\"] = key[\"TangentMode\"][0][\"_text\"]\n\n            return_data[\"animKeys\"].append(key_data)\n\n        return return_data\n\n    def _dictify(self, xml_, root=True):\n        \"\"\" Convert xml object to dictionary\n\n        Args:\n            xml_ (xml.etree.ElementTree.Element): xml data\n            root (bool, optional): is root available. Defaults to True.\n\n        Returns:\n            dict: dictionarized xml\n        \"\"\"\n\n        if root:\n            return {xml_.tag: self._dictify(xml_, False)}\n\n        d = copy(xml_.attrib)\n        if xml_.text:\n            d[\"_text\"] = xml_.text\n\n        for x in xml_.findall(\"./*\"):\n            if x.tag not in d:\n                d[x.tag] = []\n            d[x.tag].append(self._dictify(x, False))\n        return d\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.TimeEffectMetadata.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns timewarp effect data</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>retime data</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.TimeEffectMetadata.is_empty","title":"<code>is_empty</code>  <code>property</code>","text":"<p>Returns either the current object is empty or not.</p> <p>Returns:</p> Type Description <p>bool. Is the TimeEffectMetadata object empty?</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.TimeEffectMetadata.setup_data","title":"<code>setup_data</code>  <code>property</code>","text":"<p>Returns timewarp effect setup data</p> <p>Returns:</p> Type Description <p>str. The XML formatted setup data.</p>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.create_segment_data_marker","title":"<code>create_segment_data_marker(segment)</code>","text":"<p>Create AYON marker on a segment.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <p>Returns:</p> Type Description <p>flame.PyMarker: flame api object</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def create_segment_data_marker(segment):\n    \"\"\" Create AYON marker on a segment.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n\n    Returns:\n        flame.PyMarker: flame api object\n    \"\"\"\n    # get duration of segment\n    duration = segment.record_duration.relative_frame\n    # calculate start frame of the new marker\n    start_frame = int(segment.record_in.relative_frame) + int(duration / 2)\n    # create marker\n    marker = segment.create_marker(start_frame)\n    # set marker name\n    marker.name = MARKER_NAME\n    # set duration\n    marker.duration = MARKER_DURATION\n    # set colour\n    marker.colour = COLOR_MAP[MARKER_COLOR]  # Red\n\n    return marker\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_frame_from_filename","title":"<code>get_frame_from_filename(filename)</code>","text":"<p>Return sequence number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>sequence frame number</p> Example <p>def get_frame_from_filename(path):     (\"plate.0001.exr\") &gt; 0001</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_frame_from_filename(filename):\n    \"\"\"\n    Return sequence number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        int: sequence frame number\n\n    Example:\n        def get_frame_from_filename(path):\n            (\"plate.0001.exr\") &gt; 0001\n\n    \"\"\"\n\n    found = re.findall(FRAME_PATTERN, filename)\n\n    return found.pop() if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_padding_from_filename","title":"<code>get_padding_from_filename(filename)</code>","text":"<p>Return padding number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>padding number</p> Example <p>get_padding_from_filename(\"plate.0001.exr\") &gt; 4</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_padding_from_filename(filename):\n    \"\"\"\n    Return padding number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        int: padding number\n\n    Example:\n        get_padding_from_filename(\"plate.0001.exr\") &gt; 4\n\n    \"\"\"\n    found = get_frame_from_filename(filename)\n\n    return len(found) if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_publish_attribute","title":"<code>get_publish_attribute(segment)</code>","text":"<p>Get Publish attribute from input Tag object</p> Attribute <p>segment (flame.PySegment)): flame api object</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True or False</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_publish_attribute(segment):\n    \"\"\" Get Publish attribute from input Tag object\n\n    Attribute:\n        segment (flame.PySegment)): flame api object\n\n    Returns:\n        bool: True or False\n    \"\"\"\n    tag_data = get_segment_data_marker(segment)\n\n    if not tag_data:\n        set_publish_attribute(segment, MARKER_PUBLISH_DEFAULT)\n        return MARKER_PUBLISH_DEFAULT\n\n    return tag_data[\"active\"]\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_reformatted_filename","title":"<code>get_reformatted_filename(filename, padded=True)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_reformatted_filename(filename, padded=True):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    found = FRAME_PATTERN.search(filename)\n\n    if not found:\n        log.info(\"File name is not sequence: {}\".format(filename))\n        return filename\n\n    padding = get_padding_from_filename(filename)\n\n    replacement = \"%0{}d\".format(padding) if padded else \"%d\"\n    start_idx, end_idx = found.span(1)\n\n    return replacement.join(\n        [filename[:start_idx], filename[end_idx:]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_segment_attributes","title":"<code>get_segment_attributes(segment, validation_aggregator=None)</code>","text":"<p>Get attributes of a segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Segment</code> <p>Segment to get attributes from.</p> required <code>validation_aggregator</code> <code>ValidationAggregator</code> <pre><code>Output object to store attributes for passing into\npublishing validation. Defaults to None.\n</code></pre> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of attributes.</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_segment_attributes(\n    segment, validation_aggregator: ValidationAggregator = None):\n    \"\"\"Get attributes of a segment.\n\n    Args:\n        segment (Segment): Segment to get attributes from.\n        validation_aggregator (ValidationAggregator, optional):\n                Output object to store attributes for passing into\n                publishing validation. Defaults to None.\n\n    Returns:\n        dict: Dictionary of attributes.\n    \"\"\"\n    if segment.type == \"Gap\":\n        return None\n\n    if not validation_aggregator:\n        validation_aggregator = ValidationAggregator()\n\n    segment_name = segment.name.get_value()\n\n    # Add timeline segment to tree\n    clip_data = {\n        \"shot_name\": segment.shot_name.get_value(),\n        \"segment_comment\": segment.comment.get_value(),\n        \"tape_name\": segment.tape_name,\n        \"source_name\": segment.source_name,\n        \"PySegment\": segment,\n    }\n    # make sure even segments without proper name are handled as missing\n    # this way they will be detected by Publisher Validator\n    if not segment_name:\n        clip_data[\"segment_name\"] = \"Missing: Segment's Name\"\n        if segment not in validation_aggregator.failed_segments:\n            validation_aggregator.failed_segments.append(segment)\n    else:\n        clip_data[\"segment_name\"] = segment_name\n\n    # make sure even segments without file path are handled as missing\n    # this way they will be detected by Publisher Validator\n    if segment.file_path and segment_name:\n        clip_data[\"fpath\"] = segment.file_path\n    else:\n        clip_data[\"segment_name\"] = \"Missing: Segment's File Path\"\n        if segment not in validation_aggregator.failed_segments:\n            validation_aggregator.failed_segments.append(segment)\n\n    # head and tail with forward compatibility\n    if segment.head:\n        # `infinite` can be also returned\n        if isinstance(segment.head, str):\n            clip_data[\"segment_head\"] = 0\n        else:\n            clip_data[\"segment_head\"] = int(segment.head)\n    if segment.tail:\n        # `infinite` can be also returned\n        if isinstance(segment.tail, str):\n            clip_data[\"segment_tail\"] = 0\n        else:\n            clip_data[\"segment_tail\"] = int(segment.tail)\n\n    # add all available shot tokens\n    shot_tokens = _get_shot_tokens_values(segment, [\n        \"&lt;colour space&gt;\", \"&lt;width&gt;\", \"&lt;height&gt;\", \"&lt;depth&gt;\", \"&lt;segment&gt;\",\n        \"&lt;track&gt;\", \"&lt;track name&gt;\"\n    ])\n    clip_data.update(shot_tokens)\n\n    # populate shot source metadata\n    segment_attrs = [\n        \"record_duration\", \"record_in\", \"record_out\",\n        \"source_in\", \"source_out\", \"source_frame_rate\", \"source_height\",\n        \"source_width\", \"source_ratio\", \"start_frame\", \"head\", \"tail\",\n    ]\n    segment_attrs_data = {}\n    for attr_name in segment_attrs:\n        if not hasattr(segment, attr_name):\n            continue\n        attr = getattr(segment, attr_name)\n        segment_attrs_data[attr_name] = str(attr).replace(\"+\", \":\")\n\n        if attr_name in [\"record_in\", \"record_out\"]:\n            clip_data[attr_name] = attr.relative_frame\n        else:\n            if hasattr(attr, \"frame\"):\n                clip_data[attr_name] = attr.frame\n\n    clip_data[\"segment_timecodes\"] = segment_attrs_data\n    return clip_data\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.get_segment_data_marker","title":"<code>get_segment_data_marker(segment, with_marker=None)</code>","text":"<p>Get AYON track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <code>with_marker</code> <code>bool)[optional]</code> <p>if true it will return also marker object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>AYON tag data</p> <p>Returns(with_marker=True):     flame.PyMarker, dict</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def get_segment_data_marker(segment, with_marker=None):\n    \"\"\"\n    Get AYON track item tag created by creator or loader plugin.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n        with_marker (bool)[optional]: if true it will return also marker object\n\n    Returns:\n        dict: AYON tag data\n\n    Returns(with_marker=True):\n        flame.PyMarker, dict\n    \"\"\"\n    for marker in segment.markers:\n        comment = marker.comment.get_value()\n        color = marker.colour.get_value()\n        name = marker.name.get_value()\n\n        if (name == MARKER_NAME) and (\n                color == COLOR_MAP[MARKER_COLOR]):\n            if not with_marker:\n                return json.loads(comment)\n            else:\n                return marker, json.loads(comment)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.maintained_object_duplication","title":"<code>maintained_object_duplication(item)</code>","text":"<p>Maintain input item duplication</p> <p>Attributes:</p> Name Type Description <code>item</code> <code>any flame.PyObject</code> <p>python api object</p> Yield <p>duplicate input PyObject type</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_object_duplication(item):\n    \"\"\"Maintain input item duplication\n\n    Attributes:\n        item (any flame.PyObject): python api object\n\n    Yield:\n        duplicate input PyObject type\n    \"\"\"\n    import flame\n    # Duplicate the clip to avoid modifying the original clip\n    duplicate = flame.duplicate(item)\n\n    try:\n        # do the operation on selected segments\n        yield duplicate\n    finally:\n        # delete the item at the end\n        flame.delete(duplicate)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.maintained_segment_selection","title":"<code>maintained_segment_selection(sequence)</code>","text":"<p>Maintain selection during context</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>PySequence</code> <p>python api object</p> Yield <p>list of flame.PySegment</p> Example <p>with maintained_segment_selection(sequence) as selected_segments: ...     for segment in selected_segments: ...         segment.selected = False print(segment.selected) True</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_segment_selection(sequence):\n    \"\"\"Maintain selection during context\n\n    Attributes:\n        sequence (flame.PySequence): python api object\n\n    Yield:\n        list of flame.PySegment\n\n    Example:\n        &gt;&gt;&gt; with maintained_segment_selection(sequence) as selected_segments:\n        ...     for segment in selected_segments:\n        ...         segment.selected = False\n        &gt;&gt;&gt; print(segment.selected)\n        True\n    \"\"\"\n    selected_segments = get_sequence_segments(sequence, True)\n    try:\n        # do the operation on selected segments\n        yield selected_segments\n    finally:\n        # reset all selected clips\n        reset_segment_selection(sequence)\n        # select only original selection of segments\n        for segment in selected_segments:\n            segment.selected = True\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.reset_segment_selection","title":"<code>reset_segment_selection(sequence)</code>","text":"<p>Deselect all selected nodes</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def reset_segment_selection(sequence):\n    \"\"\"Deselect all selected nodes\n    \"\"\"\n    for ver in sequence.versions:\n        for track in ver.tracks:\n            if len(track.segments) == 0 and track.hidden:\n                continue\n            for segment in track.segments:\n                segment.selected = False\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.set_publish_attribute","title":"<code>set_publish_attribute(segment, value)</code>","text":"<p>Set Publish attribute in input Tag object</p> Attribute <p>segment (flame.PySegment)): flame api object value (bool): True or False</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def set_publish_attribute(segment, value):\n    \"\"\" Set Publish attribute in input Tag object\n\n    Attribute:\n        segment (flame.PySegment)): flame api object\n        value (bool): True or False\n    \"\"\"\n    tag_data = get_segment_data_marker(segment)\n    tag_data[\"active\"] = value\n\n    # set data to the active attribute\n    set_segment_data_marker(segment, tag_data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/lib.html#client.ayon_flame.api.lib.set_segment_data_marker","title":"<code>set_segment_data_marker(segment, data=None)</code>","text":"<p>Set AYON track item tag to input segment.</p> <p>Attributes:</p> Name Type Description <code>segment</code> <code>PySegment</code> <p>flame api object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>json loaded data</p> Source code in <code>client/ayon_flame/api/lib.py</code> <pre><code>def set_segment_data_marker(segment, data=None):\n    \"\"\"\n    Set AYON track item tag to input segment.\n\n    Attributes:\n        segment (flame.PySegment): flame api object\n\n    Returns:\n        dict: json loaded data\n    \"\"\"\n    data = data or dict()\n\n    marker_data = get_segment_data_marker(segment, True)\n\n    if marker_data:\n        # get available AYON tag if any\n        marker, tag_data = marker_data\n        # update tag data with new data\n        tag_data.update(data)\n        # update marker with tag data\n        marker.comment = json.dumps(tag_data)\n    else:\n        # update tag data with new data\n        marker = create_segment_data_marker(segment)\n        # add tag data to marker's comment\n        marker.comment = json.dumps(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_flame/api/pipeline.html","title":"pipeline","text":"<p>Basic AYON integration</p>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.FlameHost","title":"<code>FlameHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>class FlameHost(HostBase, ILoadHost, IPublishHost):\n    name = \"flame\"\n\n    # object variables\n    _publish_context_data = {}\n\n    def get_containers(self):\n        return ls()\n\n    def install(self):\n        \"\"\"Installing all requirements for Nuke host\"\"\"\n        install()\n\n    def get_context_data(self):\n        # TODO: find a way to implement this\n        return deepcopy(self._publish_context_data)\n\n    def update_context_data(self, data, changes):\n        # TODO: find a way to implement this\n        self._publish_context_data = deepcopy(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.FlameHost.install","title":"<code>install()</code>","text":"<p>Installing all requirements for Nuke host</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Installing all requirements for Nuke host\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.imprint","title":"<code>imprint(segment, data=None)</code>","text":"<p>Adding AYON data to Flame timeline segment.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>flame.PySegment)</code> <p>flame api object</p> required <code>data</code> <code>dict</code> <p>Any data which needst to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'asset': 'sq020sh0280',     'productType': 'render',     'productName': 'productMain' }</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def imprint(segment, data=None):\n    \"\"\"\n    Adding AYON data to Flame timeline segment.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        segment (flame.PySegment)): flame api object\n        data (dict): Any data which needst to be imprinted\n\n    Examples:\n        data = {\n            'asset': 'sq020sh0280',\n            'productType': 'render',\n            'productName': 'productMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_segment_data_marker(segment, data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def list_instances():\n    \"\"\"List all created instances from current workfile.\"\"\"\n    # TODO: list_instances\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.on_pyblish_instance_toggled","title":"<code>on_pyblish_instance_toggled(instance, old_value, new_value)</code>","text":"<p>Toggle node passthrough states on instance toggles.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def on_pyblish_instance_toggled(instance, old_value, new_value):\n    \"\"\"Toggle node passthrough states on instance toggles.\"\"\"\n\n    log.info(\"instance toggle: {}, old_value: {}, new_value:{} \".format(\n        instance, old_value, new_value))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.parse_container","title":"<code>parse_container(tl_segment, validate=True)</code>","text":"<p>Return container data from timeline_item's AYON tag.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def parse_container(tl_segment, validate=True):\n    \"\"\"Return container data from timeline_item's AYON tag.\n    \"\"\"\n    # TODO: parse_container\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance marker from track item.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def remove_instance(instance):\n    \"\"\"Remove instance marker from track item.\"\"\"\n    # TODO: remove_instance\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/pipeline.html#client.ayon_flame.api.pipeline.update_container","title":"<code>update_container(tl_segment, data=None)</code>","text":"<p>Update container data to input timeline_item's AYON tag.</p> Source code in <code>client/ayon_flame/api/pipeline.py</code> <pre><code>def update_container(tl_segment, data=None):\n    \"\"\"Update container data to input timeline_item's AYON tag.\n    \"\"\"\n    # TODO: update_container\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.ClipLoader","title":"<code>ClipLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic clip loader for Flame</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class ClipLoader(LoaderPlugin):\n    \"\"\"A basic clip loader for Flame\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n    log = log\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Set handles\",\n            default=0,\n            help=\"Also set handles to clip as In/Out marks\"\n        )\n    ]\n\n    _mapping = None\n    _host_settings = None\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n\n        plugin_type_settings = (\n            project_settings\n            .get(\"flame\", {})\n            .get(\"load\", {})\n        )\n\n        if not plugin_type_settings:\n            return\n\n        plugin_name = cls.__name__\n\n        plugin_settings = None\n        # Look for plugin settings in host specific settings\n        if plugin_name in plugin_type_settings:\n            plugin_settings = plugin_type_settings[plugin_name]\n\n        if not plugin_settings:\n            return\n\n        print(\"&gt;&gt;&gt; We have preset for {}\".format(plugin_name))\n        for option, value in plugin_settings.items():\n            if option == \"enabled\" and value is False:\n                print(\"  - is disabled by preset\")\n            elif option == \"representations\":\n                continue\n            else:\n                print(\"  - setting `{}`: `{}`\".format(option, value))\n            setattr(cls, option, value)\n\n    def get_colorspace(self, context):\n        \"\"\"Get colorspace name\n\n        Look either to version data or representation data.\n\n        Args:\n            context (dict): version context data\n\n        Returns:\n            str: colorspace name or None\n        \"\"\"\n        version_entity = context[\"version\"]\n        version_attributes = version_entity[\"attrib\"]\n        colorspace = version_attributes.get(\"colorSpace\")\n\n        if (\n            not colorspace\n            or colorspace == \"Unknown\"\n        ):\n            colorspace = context[\"representation\"][\"data\"].get(\n                \"colorspace\")\n\n        return colorspace\n\n    @classmethod\n    def get_native_colorspace(cls, input_colorspace):\n        \"\"\"Return native colorspace name.\n\n        Args:\n            input_colorspace (str | None): colorspace name\n\n        Returns:\n            str: native colorspace name defined in mapping or None\n        \"\"\"\n        # TODO: rewrite to support only pipeline's remapping\n        if not cls._host_settings:\n            cls._host_settings = get_current_project_settings()[\"flame\"]\n\n        # [Deprecated] way of remapping\n        if not cls._mapping:\n            mapping = (\n                cls._host_settings[\"imageio\"][\"profilesMapping\"][\"inputs\"])\n            cls._mapping = {\n                input[\"ocioName\"]: input[\"flameName\"]\n                for input in mapping\n            }\n\n        native_name = cls._mapping.get(input_colorspace)\n\n        if not native_name:\n            native_name = get_remapped_colorspace_to_native(\n                input_colorspace, \"flame\", cls._host_settings[\"imageio\"])\n\n        return native_name\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.ClipLoader.get_colorspace","title":"<code>get_colorspace(context)</code>","text":"<p>Get colorspace name</p> <p>Look either to version data or representation data.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>version context data</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>colorspace name or None</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>def get_colorspace(self, context):\n    \"\"\"Get colorspace name\n\n    Look either to version data or representation data.\n\n    Args:\n        context (dict): version context data\n\n    Returns:\n        str: colorspace name or None\n    \"\"\"\n    version_entity = context[\"version\"]\n    version_attributes = version_entity[\"attrib\"]\n    colorspace = version_attributes.get(\"colorSpace\")\n\n    if (\n        not colorspace\n        or colorspace == \"Unknown\"\n    ):\n        colorspace = context[\"representation\"][\"data\"].get(\n            \"colorspace\")\n\n    return colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.ClipLoader.get_native_colorspace","title":"<code>get_native_colorspace(input_colorspace)</code>  <code>classmethod</code>","text":"<p>Return native colorspace name.</p> <p>Parameters:</p> Name Type Description Default <code>input_colorspace</code> <code>str | None</code> <p>colorspace name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>native colorspace name defined in mapping or None</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>@classmethod\ndef get_native_colorspace(cls, input_colorspace):\n    \"\"\"Return native colorspace name.\n\n    Args:\n        input_colorspace (str | None): colorspace name\n\n    Returns:\n        str: native colorspace name defined in mapping or None\n    \"\"\"\n    # TODO: rewrite to support only pipeline's remapping\n    if not cls._host_settings:\n        cls._host_settings = get_current_project_settings()[\"flame\"]\n\n    # [Deprecated] way of remapping\n    if not cls._mapping:\n        mapping = (\n            cls._host_settings[\"imageio\"][\"profilesMapping\"][\"inputs\"])\n        cls._mapping = {\n            input[\"ocioName\"]: input[\"flameName\"]\n            for input in mapping\n        }\n\n    native_name = cls._mapping.get(input_colorspace)\n\n    if not native_name:\n        native_name = get_remapped_colorspace_to_native(\n            input_colorspace, \"flame\", cls._host_settings[\"imageio\"])\n\n    return native_name\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.FlameCreator","title":"<code>FlameCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Creator class wrapper</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class FlameCreator(Creator):\n    \"\"\"Creator class wrapper\n    \"\"\"\n    settings_category = \"flame\"\n\n    def __init__(self, *args, **kwargs):\n        super(Creator, self).__init__(*args, **kwargs)\n        project_settings = self.create_context.get_current_project_settings()\n        self.presets = project_settings[\"flame\"][\"create\"].get(\n            self.__class__.__name__, {}\n        )\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Prepare data for new instance creation.\n\n        Args:\n            product_name(str): Product name of created instance.\n            instance_data(dict): Base data for instance.\n            pre_create_data(dict): Data based on pre creation attributes.\n                Those may affect how creator works.\n        \"\"\"\n        # adding basic current context resolve objects\n        self.project = flib.get_current_project()\n        self.sequence = flib.get_current_sequence(flib.CTX.selection)\n\n        selected = pre_create_data.get(\"use_selection\", False)\n        self.selected = flib.get_sequence_segments(\n            self.sequence,\n            selected=selected\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.FlameCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Prepare data for new instance creation.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Product name of created instance.</p> required <code>instance_data</code> <code>dict</code> <p>Base data for instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data based on pre creation attributes. Those may affect how creator works.</p> required Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Prepare data for new instance creation.\n\n    Args:\n        product_name(str): Product name of created instance.\n        instance_data(dict): Base data for instance.\n        pre_create_data(dict): Data based on pre creation attributes.\n            Those may affect how creator works.\n    \"\"\"\n    # adding basic current context resolve objects\n    self.project = flib.get_current_project()\n    self.sequence = flib.get_current_sequence(flib.CTX.selection)\n\n    selected = pre_create_data.get(\"use_selection\", False)\n    self.selected = flib.get_sequence_segments(\n        self.sequence,\n        selected=selected\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.HiddenFlameCreator","title":"<code>HiddenFlameCreator</code>","text":"<p>               Bases: <code>HiddenCreator</code></p> <p>HiddenCreator class wrapper</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class HiddenFlameCreator(HiddenCreator):\n    \"\"\"HiddenCreator class wrapper\n    \"\"\"\n    settings_category = \"flame\"\n\n    def collect_instances(self):\n        pass\n\n    def update_instances(self, update_list):\n        pass\n\n    def remove_instances(self, instances):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.OpenClipSolver","title":"<code>OpenClipSolver</code>","text":"<p>               Bases: <code>MediaInfoFile</code></p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class OpenClipSolver(flib.MediaInfoFile):\n    create_new_clip = False\n\n    log = log\n\n    def __init__(self, openclip_file_path, feed_data, logger=None):\n        self.out_file = openclip_file_path\n\n        # replace log if any\n        if logger:\n            self.log = logger\n\n        # new feed variables:\n        feed_path = feed_data.pop(\"path\")\n\n        # initialize parent class\n        super(OpenClipSolver, self).__init__(\n            feed_path,\n            logger=logger\n        )\n\n        # get other metadata\n        self.feed_version_name = feed_data[\"version\"]\n        self.feed_colorspace = feed_data.get(\"colorspace\")\n        self.log.debug(\"feed_version_name: {}\".format(self.feed_version_name))\n\n        # layer rename variables\n        self.layer_rename_template = feed_data[\"layer_rename_template\"]\n        self.layer_rename_patterns = feed_data[\"layer_rename_patterns\"]\n        self.context_data = feed_data[\"context_data\"]\n\n        # derivate other feed variables\n        self.feed_basename = os.path.basename(feed_path)\n        self.feed_dir = os.path.dirname(feed_path)\n        self.feed_ext = os.path.splitext(self.feed_basename)[1][1:].lower()\n        self.log.debug(\"feed_ext: {}\".format(self.feed_ext))\n        self.log.debug(\"out_file: {}\".format(self.out_file))\n        if not self._is_valid_tmp_file(self.out_file):\n            self.create_new_clip = True\n\n    def _is_valid_tmp_file(self, file):\n        # check if file exists\n        if os.path.isfile(file):\n            # test also if file is not empty\n            with open(file) as f:\n                lines = f.readlines()\n\n            if len(lines) &gt; 2:\n                return True\n\n            # file is probably corrupted\n            os.remove(file)\n            return False\n\n    def make(self):\n\n        if self.create_new_clip:\n            # New openClip\n            self._create_new_open_clip()\n        else:\n            self._update_open_clip()\n\n    def _clear_handler(self, xml_object):\n        for handler in xml_object.findall(\"./handler\"):\n            self.log.info(\"Handler found\")\n            xml_object.remove(handler)\n\n    def _create_new_open_clip(self):\n        self.log.info(\"Building new openClip\")\n\n        for tmp_xml_track in self.clip_data.iter(\"track\"):\n            # solve track (layer) name\n            self._rename_track_name(tmp_xml_track)\n\n            tmp_xml_feeds = tmp_xml_track.find('feeds')\n            tmp_xml_feeds.set('currentVersion', self.feed_version_name)\n\n            for tmp_feed in tmp_xml_track.iter(\"feed\"):\n                tmp_feed.set('vuid', self.feed_version_name)\n\n                # add colorspace if any is set\n                if self.feed_colorspace:\n                    self._add_colorspace(tmp_feed, self.feed_colorspace)\n\n                self._clear_handler(tmp_feed)\n\n        tmp_xml_versions_obj = self.clip_data.find('versions')\n        tmp_xml_versions_obj.set('currentVersion', self.feed_version_name)\n        for xml_new_version in tmp_xml_versions_obj:\n            xml_new_version.set('uid', self.feed_version_name)\n            xml_new_version.set('type', 'version')\n\n        self._clear_handler(self.clip_data)\n        self.log.info(\"Adding feed version: {}\".format(self.feed_basename))\n\n        self.write_clip_data_to_file(self.out_file, self.clip_data)\n\n    def _get_xml_track_obj_by_uid(self, xml_data, uid):\n        # loop all tracks of input xml data\n        for xml_track in xml_data.iter(\"track\"):\n            track_uid = xml_track.get(\"uid\")\n            self.log.debug(\n                \"&gt;&gt; track_uid:uid: {}:{}\".format(track_uid, uid))\n\n            # get matching uids\n            if uid == track_uid:\n                return xml_track\n\n    def _rename_track_name(self, xml_track_data):\n        layer_uid = xml_track_data.get(\"uid\")\n        name_obj = xml_track_data.find(\"name\")\n        layer_name = name_obj.text\n\n        if (\n            self.layer_rename_patterns\n            and not any(\n                re.search(lp_.lower(), layer_name.lower())\n                for lp_ in self.layer_rename_patterns\n            )\n        ):\n            return\n\n        formatting_data = self._update_formatting_data(\n            layerName=layer_name,\n            layerUID=layer_uid\n        )\n        name_obj.text = StringTemplate(\n            self.layer_rename_template\n        ).format(formatting_data)\n\n    def _update_formatting_data(self, **kwargs):\n        \"\"\" Updating formatting data for layer rename\n\n        Attributes:\n            key=value (optional): will be included to formatting data\n                                  as {key: value}\n        Returns:\n            dict: anatomy context data for formatting\n        \"\"\"\n        self.log.debug(\"&gt;&gt; self.clip_data: {}\".format(self.clip_data))\n        clip_name_obj = self.clip_data.find(\"name\")\n        data = {\n            \"originalBasename\": clip_name_obj.text\n        }\n        # include version context data\n        data.update(self.context_data)\n        # include input kwargs data\n        data.update(kwargs)\n        return data\n\n    def _update_open_clip(self):\n        self.log.info(\"Updating openClip ..\")\n\n        out_xml = ET.parse(self.out_file)\n        out_xml = out_xml.getroot()\n\n        self.log.debug(\"&gt;&gt; out_xml: {}\".format(out_xml))\n        # loop tmp tracks\n        updated_any = False\n        for tmp_xml_track in self.clip_data.iter(\"track\"):\n            # solve track (layer) name\n            self._rename_track_name(tmp_xml_track)\n\n            # get tmp track uid\n            tmp_track_uid = tmp_xml_track.get(\"uid\")\n            self.log.debug(\"&gt;&gt; tmp_track_uid: {}\".format(tmp_track_uid))\n\n            # get out data track by uid\n            out_track_element = self._get_xml_track_obj_by_uid(\n                out_xml, tmp_track_uid)\n            self.log.debug(\n                \"&gt;&gt; out_track_element: {}\".format(out_track_element))\n\n            # loop tmp feeds\n            for tmp_xml_feed in tmp_xml_track.iter(\"feed\"):\n                new_path_obj = tmp_xml_feed.find(\n                    \"spans/span/path\")\n                new_path = new_path_obj.text\n\n                # check if feed path already exists in track's feeds\n                if (\n                    out_track_element is not None\n                    and self._feed_exists(out_track_element, new_path)\n                ):\n                    continue\n\n                # rename versions on feeds\n                tmp_xml_feed.set('vuid', self.feed_version_name)\n                self._clear_handler(tmp_xml_feed)\n\n                # update fps from MediaInfoFile class\n                if self.fps is not None:\n                    tmp_feed_fps_obj = tmp_xml_feed.find(\n                        \"startTimecode/rate\")\n                    tmp_feed_fps_obj.text = str(self.fps)\n\n                # update start_frame from MediaInfoFile class\n                if self.start_frame is not None:\n                    tmp_feed_nb_ticks_obj = tmp_xml_feed.find(\n                        \"startTimecode/nbTicks\")\n                    tmp_feed_nb_ticks_obj.text = str(self.start_frame)\n\n                # update drop_mode from MediaInfoFile class\n                if self.drop_mode is not None:\n                    tmp_feed_drop_mode_obj = tmp_xml_feed.find(\n                        \"startTimecode/dropMode\")\n                    tmp_feed_drop_mode_obj.text = str(self.drop_mode)\n\n                # add colorspace if any is set\n                if self.feed_colorspace is not None:\n                    self._add_colorspace(tmp_xml_feed, self.feed_colorspace)\n\n                # then append/update feed to correct track in output\n                if out_track_element:\n                    self.log.debug(\"updating track element ..\")\n                    # update already present track\n                    out_feeds = out_track_element.find('feeds')\n                    out_feeds.set('currentVersion', self.feed_version_name)\n                    out_feeds.append(tmp_xml_feed)\n\n                    self.log.info(\n                        \"Appending new feed: {}\".format(\n                            self.feed_version_name))\n                else:\n                    self.log.debug(\"adding new track element ..\")\n                    # create new track as it doesn't exist yet\n                    # set current version to feeds on tmp\n                    tmp_xml_feeds = tmp_xml_track.find('feeds')\n                    tmp_xml_feeds.set('currentVersion', self.feed_version_name)\n                    out_tracks = out_xml.find(\"tracks\")\n                    out_tracks.append(tmp_xml_track)\n\n                updated_any = True\n\n        if updated_any:\n            # Append vUID to versions\n            out_xml_versions_obj = out_xml.find('versions')\n            out_xml_versions_obj.set(\n                'currentVersion', self.feed_version_name)\n            new_version_obj = ET.Element(\n                \"version\", {\"type\": \"version\", \"uid\": self.feed_version_name})\n            out_xml_versions_obj.insert(0, new_version_obj)\n\n            self._clear_handler(out_xml)\n\n            # fist create backup\n            self._create_openclip_backup_file(self.out_file)\n\n            self.log.info(\"Adding feed version: {}\".format(\n                self.feed_version_name))\n\n            self.write_clip_data_to_file(self.out_file, out_xml)\n\n            self.log.debug(\"OpenClip Updated: {}\".format(self.out_file))\n\n    def _feed_exists(self, xml_data, path):\n        # loop all available feed paths and check if\n        # the path is not already in file\n        for src_path in xml_data.iter('path'):\n            if path == src_path.text:\n                self.log.warning(\n                    \"Not appending file as it already is in .clip file\")\n                return True\n\n    def _create_openclip_backup_file(self, file):\n        bck_file = \"{}.bak\".format(file)\n        # if backup does not exist\n        if not os.path.isfile(bck_file):\n            shutil.copy2(file, bck_file)\n        else:\n            # in case it exists and is already multiplied\n            created = False\n            for _i in range(1, 99):\n                bck_file = \"{name}.bak.{idx:0&gt;2}\".format(\n                    name=file,\n                    idx=_i)\n                # create numbered backup file\n                if not os.path.isfile(bck_file):\n                    shutil.copy2(file, bck_file)\n                    created = True\n                    break\n            # in case numbered does not exists\n            if not created:\n                bck_file = \"{}.bak.last\".format(file)\n                shutil.copy2(file, bck_file)\n\n    def _add_colorspace(self, feed_obj, profile_name):\n        feed_storage_obj = feed_obj.find(\"storageFormat\")\n        feed_clr_obj = feed_storage_obj.find(\"colourSpace\")\n        if feed_clr_obj is not None:\n            feed_clr_obj = ET.Element(\n                \"colourSpace\", {\"type\": \"string\"})\n            feed_clr_obj.text = profile_name\n            feed_storage_obj.append(feed_clr_obj)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/plugin.html#client.ayon_flame.api.plugin.PublishableClip","title":"<code>PublishableClip</code>","text":"<p>Convert a segment to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>PySegment</code> <p>flame api object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>flame.PySegment: flame api object</p> Source code in <code>client/ayon_flame/api/plugin.py</code> <pre><code>class PublishableClip:\n    \"\"\"\n    Convert a segment to publishable instance\n\n    Args:\n        segment (flame.PySegment): flame api object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        flame.PySegment: flame api object\n    \"\"\"\n    vertical_clip_match = {}\n    vertical_clip_used = {}\n    marker_data = {}\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    review_source_default = None\n    base_product_variant_default = \"&lt;track_name&gt;\"\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n    index_from_segment_default = False\n    use_shot_name_default = False\n    include_handles_default = False\n    retimed_handles_default = True\n    retimed_framerange_default = True\n\n    def __init__(self,\n            segment,\n            pre_create_data=None,\n            data=None,\n            product_type=None,\n            rename_index=None,\n            log=None,\n        ):\n        self.rename_index = rename_index\n        self.product_type = product_type\n        self.log = log\n        self.pre_create_data = pre_create_data or {}\n\n        # get main parent objects\n        self.current_segment = segment\n        sequence_name = flib.get_current_sequence([segment]).name.get_value()\n        self.sequence_name = str(sequence_name).replace(\" \", \"_\")\n        self.clip_data = flib.get_segment_attributes(segment)\n\n        # segment (clip) main attributes\n        self.cs_name = self.clip_data[\"segment_name\"]\n        self.cs_index = int(self.clip_data[\"segment\"])\n        self.shot_name = self.clip_data[\"shot_name\"]\n\n        # get track name and index\n        self.track_index = int(self.clip_data[\"track\"])\n        track_name = self.clip_data[\"track_name\"]\n        self.track_name = (\n            # make sure no space and other special characters are in track name\n            # default track name is `*`\n            str(track_name)\n            .replace(\" \", \"_\")\n            .replace(\"*\", f\"noname{self.track_index}\")\n        )\n\n        # add publish attribute to marker data\n        self.marker_data.update({\"active\": True})\n\n        # adding input data if any\n        if data:\n            self.marker_data.update(data)\n\n        # populate default data before we get other attributes\n        self._populate_segment_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    @classmethod\n    def restore_all_caches(cls):\n        cls.vertical_clip_match = {}\n        cls.vertical_clip_used = {}\n\n    def convert(self):\n\n        # solve segment data and add them to marker data\n        self._convert_to_marker_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (self.track_name in self.reviewable_source) and (\n                self.driving_layer not in self.reviewable_source):\n            return\n\n        # deal with clip name\n        new_name = self.marker_data.pop(\"newClipName\")\n        hierarchy_filled = self.marker_data[\"hierarchy\"]\n\n        if self.rename and not self.use_shot_name:\n            # rename segment\n            self.current_segment.name = str(new_name)\n            self.marker_data.update({\n                \"folderName\": str(new_name),\n                \"folderPath\": f\"/{hierarchy_filled}/{new_name}\"\n            })\n\n        elif self.use_shot_name:\n            if not self.shot_name:\n                raise CreatorError(\n                    f\"Shot name is not set on segment: {self.cs_name}\")\n            self.marker_data.update({\n                \"folderName\": self.shot_name,\n                \"folderPath\": f\"/{hierarchy_filled}/{self.shot_name}\",\n                \"hierarchyData\": {\n                    \"shot\": self.shot_name\n                }\n            })\n        else:\n            self.marker_data.update({\n                \"folderName\": self.cs_name,\n                \"folderPath\": f\"/{hierarchy_filled}/{self.cs_name}\",\n                \"hierarchyData\": {\n                    \"shot\": self.cs_name\n                }\n            })\n\n        return self.current_segment\n\n    def _populate_segment_default_data(self):\n        \"\"\" Populate default formatting data from segment. \"\"\"\n\n        self.current_segment_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.sequence_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.cs_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.cs_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # segment frame range and parent track name for vertical sync check\n        self.clip_in = int(self.clip_data[\"record_in\"])\n        self.clip_out = int(self.clip_data[\"record_out\"])\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.cs_index\n        self.log.debug(f\"____ self.shot_num: {self.shot_num}\")\n\n        # Use pre-create data or default values if gui was not used\n        self.rename = self.pre_create_data.get(\n            \"clipRename\") or self.rename_default\n        self.use_shot_name = self.pre_create_data.get(\n            \"useShotName\") or self.use_shot_name_default\n        self.clip_name = self.pre_create_data.get(\n            \"clipName\") or self.clip_name_default\n        self.hierarchy = self.pre_create_data.get(\n            \"hierarchy\") or self.hierarchy_default\n        self.hierarchy_data = self.pre_create_data.get(\n            \"hierarchyData\") or self.current_segment_default_data.copy()\n        self.index_from_segment = self.pre_create_data.get(\n            \"segmentIndex\") or self.index_from_segment_default\n        self.count_from = self.pre_create_data.get(\n            \"countFrom\") or self.count_from_default\n        self.count_steps = self.pre_create_data.get(\n            \"countSteps\") or self.count_steps_default\n        self.base_product_variant = self.pre_create_data.get(\n            \"clipVariant\") or self.base_product_variant_default\n        self.product_type = (\n            self.pre_create_data.get(\"productType\")\n            or self.product_type_default\n        )\n        self.vertical_sync = self.pre_create_data.get(\n            \"vSyncOn\") or self.vertical_sync_default\n        self.driving_layer = self.pre_create_data.get(\n            \"vSyncTrack\") or self.driving_layer_default\n        self.review_source = self.pre_create_data.get(\n            \"reviewableSource\") or self.review_source_default\n        self.audio = self.pre_create_data.get(\"export_audio\") or False\n        self.include_handles = self.pre_create_data.get(\n            \"includeHandles\") or self.include_handles_default\n        self.retimed_handles = (\n            self.pre_create_data.get(\"retimedHandles\")\n            or self.retimed_handles_default\n        )\n        self.retimed_framerange = (\n            self.pre_create_data.get(\"retimedFramerange\")\n            or self.retimed_framerange_default\n        )\n\n        # build product name from layer name\n        if self.base_product_variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n        else:\n            self.variant = self.base_product_variant\n\n        # create product for publishing\n        self.product_name = (\n            self.product_type + self.variant.capitalize()\n        )\n\n        self.hierarchy_data = {\n            key: self.pre_create_data.get(key)\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        return text.replace((\"#\" * _len), _repl)\n\n    def _convert_to_marker_data(self):\n        \"\"\" Convert internal data to marker data.\n\n        Populating the marker data into internal variable self.marker_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n\n        if (\n            self.vertical_sync and\n            self.track_name not in self.driving_layer\n        ):\n            # if it is not then define vertical sync as None\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        if not self.index_from_segment:\n            self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        hierarchy_data = deepcopy(self.hierarchy_data)\n        _data = self.current_segment_default_data.copy()\n\n        if self.pre_create_data:\n\n            # backward compatibility for reviewableSource (2024.12.02)\n            if \"reviewTrack\" in self.pre_create_data:\n                _value = self.marker_data.pop(\"reviewTrack\")\n                self.marker_data[\"reviewableSource\"] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review layer\n                if self.review_source and (\n                        self.review_source != self.review_source_default):\n                    # if review layer is defined and not the same as default\n                    self.reviewable_source  = self.review_source\n\n                # shot num calculate\n                if self.index_from_segment:\n                    # use clip index from timeline\n                    self.shot_num = self.count_steps * self.cs_index\n                else:\n                    if self.rename_index == 0:\n                        self.shot_num = self.count_from\n                    else:\n                        self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _k, _v in hierarchy_data.items():\n                if \"#\" not in _v:\n                    continue\n                hierarchy_data[_k] = self._replace_hash_to_expression(_k, _v)\n\n            # fill up pythonic expresisons in hierarchy data\n            for k, _v in hierarchy_data.items():\n                hierarchy_formatting_data[k] = str(_v).format(**_data)\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = hierarchy_data\n\n        tag_instance_data = self._solve_tag_instance_data(\n            hierarchy_formatting_data)\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update({\n                (self.clip_in, self.clip_out): tag_instance_data\n            })\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\" Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", []\n                )\n                self.log.debug(\n                    f\"&gt;&gt; used_names_list: {used_names_list}\"\n                )\n                clip_product_name = self.product_name\n                variant = self.variant\n                self.log.debug(\n                    f\"&gt;&gt; clip_product_name: {clip_product_name}\")\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    _clip_product_name = (\n                        f\"{clip_product_name}{self.cs_index}\"\n                    )\n                    # just in case lets validate if new name is not used\n                    # in case the track_index is the same as clip_index\n                    if _clip_product_name in used_names_list:\n                        _clip_product_name = (\n                            f\"{clip_product_name}\"\n                            f\"{self.track_index}{self.cs_index}\"\n                        )\n                    clip_product_name = _clip_product_name\n                    variant = f\"{variant}{self.cs_index}\"\n\n                self.log.debug(\n                    f\"&gt;&gt; clip_product_name: {clip_product_name}\")\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.marker_data.update(tag_instance_data)\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.marker_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.marker_data[\"reviewTrack\"] = None\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.marker_data[\"review\"] = True\n            else:\n                self.marker_data.pop(\"review\", None)\n\n            self.marker_data[\"reviewableSource\"] = reviewable_source\n\n    def _solve_tag_instance_data(self, hierarchy_formatting_data):\n        \"\"\" Solve marker data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        # remove shot from hierarchy data: is not needed anymore\n        hierarchy_formatting_data.pop(\"shot\")\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type_default,\n            \"variant\": self.variant,\n        }\n\n    def _convert_to_entity(self, src_type, template):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(src_type, None)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            src_type\n        )\n\n        # first collect formatting data to use for formatting template\n        formatting_data = {}\n        for _k, _v in self.hierarchy_data.items():\n            value = str(_v).format(\n                **self.current_segment_default_data)\n            formatting_data[_k] = value\n\n        return {\n            \"folder_type\": folder_type,\n            \"entity_name\": template.format(\n                **formatting_data\n            )\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n\n        par_split = [(pattern.findall(t).pop(), t)\n                     for t in self.hierarchy.split(\"/\")]\n\n        for type, template in par_split:\n            parent = self._convert_to_entity(type, template)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/render_utils.html","title":"render_utils","text":""},{"location":"autoapi/client/ayon_flame/api/render_utils.html#client.ayon_flame.api.render_utils.export_clip","title":"<code>export_clip(export_path, clip, preset_path, **kwargs)</code>","text":"<p>Flame exported wrapper</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>str</code> <p>exporting directory path</p> required <code>clip</code> <code>PyClip</code> <p>flame api object</p> required <code>preset_path</code> <code>str</code> <p>full export path to xml file</p> required Kwargs <p>thumb_frame_number (int)[optional]: source frame number in_mark (int)[optional]: cut in mark out_mark (int)[optional]: cut out mark</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Missing input kwarg <code>thumb_frame_number</code>       in case <code>thumbnail</code> in <code>export_preset</code></p> <code>FileExistsError</code> <p>Missing export preset in shared folder</p> Source code in <code>client/ayon_flame/api/render_utils.py</code> <pre><code>def export_clip(export_path, clip, preset_path, **kwargs):\n    \"\"\"Flame exported wrapper\n\n    Args:\n        export_path (str): exporting directory path\n        clip (PyClip): flame api object\n        preset_path (str): full export path to xml file\n\n    Kwargs:\n        thumb_frame_number (int)[optional]: source frame number\n        in_mark (int)[optional]: cut in mark\n        out_mark (int)[optional]: cut out mark\n\n    Raises:\n        KeyError: Missing input kwarg `thumb_frame_number`\n                  in case `thumbnail` in `export_preset`\n        FileExistsError: Missing export preset in shared folder\n    \"\"\"\n    import flame\n\n    in_mark = out_mark = None\n\n    # Set exporter\n    exporter = flame.PyExporter()\n    exporter.foreground = True\n    exporter.export_between_marks = True\n\n    if kwargs.get(\"thumb_frame_number\"):\n        thumb_frame_number = kwargs[\"thumb_frame_number\"]\n        # make sure it exists in kwargs\n        if not thumb_frame_number:\n            raise KeyError(\n                \"Missing key `thumb_frame_number` in input kwargs\")\n\n        in_mark = int(thumb_frame_number)\n        out_mark = int(thumb_frame_number) + 1\n\n    elif kwargs.get(\"in_mark\") and kwargs.get(\"out_mark\"):\n        in_mark = int(kwargs[\"in_mark\"])\n        out_mark = int(kwargs[\"out_mark\"])\n    else:\n        exporter.export_between_marks = False\n\n    try:\n        # set in and out marks if they are available\n        if in_mark and out_mark:\n            clip.in_mark = in_mark\n            clip.out_mark = out_mark\n\n        # export with exporter\n        exporter.export(clip, preset_path, export_path)\n    finally:\n        print('Exported: {} at {}-{}'.format(\n            clip.name.get_value(),\n            clip.in_mark,\n            clip.out_mark\n        ))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/render_utils.html#client.ayon_flame.api.render_utils.modify_preset_file","title":"<code>modify_preset_file(xml_path, staging_dir, data)</code>","text":"<p>Modify xml preset with input data</p> <p>Parameters:</p> Name Type Description Default <code>xml_path</code> <code>str</code> <p>path for input xml preset</p> required <code>staging_dir</code> <code>str</code> <p>staging dir path</p> required <code>data</code> <code>dict</code> <p>data where key is xmlTag and value as string</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>description</p> Source code in <code>client/ayon_flame/api/render_utils.py</code> <pre><code>def modify_preset_file(xml_path, staging_dir, data):\n    \"\"\"Modify xml preset with input data\n\n    Args:\n        xml_path (str ): path for input xml preset\n        staging_dir (str): staging dir path\n        data (dict): data where key is xmlTag and value as string\n\n    Returns:\n        str: _description_\n    \"\"\"\n    # create temp path\n    dirname, basename = os.path.split(xml_path)\n    temp_path = os.path.join(staging_dir, basename)\n\n    # change xml following data keys\n    with open(xml_path, \"r\") as datafile:\n        _root = ET.parse(datafile)\n\n        for key, value in data.items():\n            try:\n                if \"/\" in key:\n                    if not key.startswith(\"./\"):\n                        key = \".//\" + key\n\n                    split_key_path = key.split(\"/\")\n                    element_key = split_key_path[-1]\n                    parent_obj_path = \"/\".join(split_key_path[:-1])\n\n                    parent_obj = _root.find(parent_obj_path)\n                    element_obj = parent_obj.find(element_key)\n                    if not element_obj:\n                        append_element(parent_obj, element_key, value)\n                else:\n                    finds = _root.findall(\".//{}\".format(key))\n                    if not finds:\n                        raise AttributeError\n                    for element in finds:\n                        element.text = str(value)\n            except AttributeError:\n                log.warning(\n                    \"Cannot create attribute: {}: {}. Skipping\".format(\n                        key, value\n                    ))\n        _root.write(temp_path)\n\n    return temp_path\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/utils.html","title":"utils","text":"<p>Flame utils for syncing scripts</p>"},{"location":"autoapi/client/ayon_flame/api/utils.html#client.ayon_flame.api.utils.setup","title":"<code>setup(env=None)</code>","text":"<p>Wrapper installer started from <code>flame/hooks/pre_flame_setup.py</code></p> Source code in <code>client/ayon_flame/api/utils.py</code> <pre><code>def setup(env=None):\n    \"\"\" Wrapper installer started from\n    `flame/hooks/pre_flame_setup.py`\n    \"\"\"\n    env = env or os.environ\n\n    # synchronize resolve utility scripts\n    _sync_utility_scripts(env)\n\n    log.info(\"Flame AYON wrapper has been installed\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_flame/api/scripts/index.html","title":"scripts","text":""},{"location":"autoapi/client/ayon_flame/api/scripts/wiretap_com.html","title":"wiretap_com","text":""},{"location":"autoapi/client/ayon_flame/api/scripts/wiretap_com.html#client.ayon_flame.api.scripts.wiretap_com.WireTapCom","title":"<code>WireTapCom</code>","text":"<p>               Bases: <code>object</code></p> <p>Comunicator class wrapper for talking to WireTap db.</p> <p>This way we are able to set new project with settings and correct colorspace policy. Also we are able to create new user or get actual user with similar name (users are usually cloning their profiles and adding date stamp into suffix).</p> Source code in <code>client/ayon_flame/api/scripts/wiretap_com.py</code> <pre><code>class WireTapCom(object):\n    \"\"\"\n    Comunicator class wrapper for talking to WireTap db.\n\n    This way we are able to set new project with settings and\n    correct colorspace policy. Also we are able to create new user\n    or get actual user with similar name (users are usually cloning\n    their profiles and adding date stamp into suffix).\n    \"\"\"\n\n    def __init__(self, host_name=None, volume_name=None, group_name=None):\n        \"\"\"Initialisation of WireTap communication class\n\n        Args:\n            host_name (str, optional): Name of host server. Defaults to None.\n            volume_name (str, optional): Name of volume. Defaults to None.\n            group_name (str, optional): Name of user group. Defaults to None.\n        \"\"\"\n        # set main attributes of server\n        # if there are none set the default installation\n        self.host_name = host_name or \"localhost\"\n        self.volume_name = volume_name or \"stonefs\"\n        self.group_name = group_name or \"staff\"\n\n        # wiretap tools dir path\n        self.wiretap_tools_dir = os.getenv(\"AYON_WIRETAP_TOOLS\")\n\n        # initialize WireTap client\n        WireTapClientInit()\n\n        # add the server to shared variable\n        self._server = WireTapServerHandle(\"{}:IFFFS\".format(self.host_name))\n        print(\"WireTap connected at '{}'...\".format(\n            self.host_name))\n\n    def close(self):\n        self._server = None\n        WireTapClientUninit()\n        print(\"WireTap closed...\")\n\n    def get_launch_args(\n            self, project_name, project_data, user_name, *args, **kwargs):\n        \"\"\"Forming launch arguments for AYON launcher.\n\n        Args:\n            project_name (str): name of project\n            project_data (dict): Flame compatible project data\n            user_name (str): name of user\n\n        Returns:\n            list: arguments\n        \"\"\"\n\n        workspace_name = kwargs.get(\"workspace_name\")\n        color_policy = kwargs.get(\"color_policy\")\n\n        project_exists = self._project_prep(project_name)\n        if not project_exists:\n            self._set_project_settings(project_name, project_data)\n            self._set_project_colorspace(project_name, color_policy)\n\n        launch_args = [\n            \"--start-project={}\".format(project_name),\n            \"--create-workspace\",\n        ]\n\n        # user profiles have been removed in flame 2025\n        if self._get_flame_year() &lt; 2025:\n            user_name = self._user_prep(user_name)\n            launch_args.append(\"--start-user={}\".format(user_name))\n\n        if workspace_name is None:\n            # default workspace\n            print(\"Using a default workspace\")\n            return launch_args\n\n        else:\n            print(\n                \"Using a custom workspace '{}'\".format(workspace_name))\n\n            self._workspace_prep(project_name, workspace_name)\n            launch_args.append(\"--start-workspace={}\".format(workspace_name))\n            return launch_args\n\n    def _get_flame_year(self):\n        \"\"\"Get the flame release year.\n\n        Returns:\n            int: The flame year, e.g. 2025\n\n        Raises:\n            AttributeError: unable to retrieve the flame version number.\n        \"\"\"\n        version_major = WireTapInt(0)\n        version_minor = WireTapInt(0)\n\n        version_exists = self._server.getVersion(version_major, version_minor)\n\n        if not version_exists:\n            raise AttributeError(\n                    \"Cannot get flame version details: {}\".format(\n                        self._server.lastError()\n                    )\n                )\n        return int(version_major)\n\n    def _workspace_prep(self, project_name, workspace_name):\n        \"\"\"Preparing a workspace\n\n        In case it doesn not exists it will create one\n\n        Args:\n            project_name (str): project name\n            workspace_name (str): workspace name\n\n        Raises:\n            AttributeError: unable to create workspace\n        \"\"\"\n        workspace_exists = self._child_is_in_parent_path(\n            \"/projects/{}\".format(project_name), workspace_name, \"WORKSPACE\"\n        )\n        if not workspace_exists:\n            project = WireTapNodeHandle(\n                self._server, \"/projects/{}\".format(project_name))\n\n            workspace_node = WireTapNodeHandle()\n            created_workspace = project.createNode(\n                workspace_name, \"WORKSPACE\", workspace_node)\n\n            if not created_workspace:\n                raise AttributeError(\n                    \"Cannot create workspace `{}` in \"\n                    \"project `{}`: `{}`\".format(\n                        workspace_name, project_name, project.lastError())\n                )\n\n        print(\n            \"Workspace `{}` is successfully created\".format(workspace_name))\n\n    def _project_prep(self, project_name):\n        \"\"\"Preparing a project\n\n        In case it doesn not exists it will create one\n\n        Args:\n            project_name (str): project name\n\n        Raises:\n            AttributeError: unable to create project\n        \"\"\"\n        # test if projeft exists\n        project_exists = self._child_is_in_parent_path(\n            \"/projects\", project_name, \"PROJECT\")\n\n        # volumes were removed in flame 2026\n        correct_flame_version = self._get_flame_year() &lt; 2026\n\n        if not correct_flame_version:\n            # flame 2026 does not use /volumes anymore\n            return True\n\n        if not project_exists:\n            volumes = self._get_all_volumes()\n\n            if len(volumes) == 0 and correct_flame_version:\n                raise AttributeError(\n                    \"Not able to create new project. No Volumes existing\"\n                )\n\n            # check if volumes exists\n            if self.volume_name not in volumes:\n                raise AttributeError(\n                    (\"Volume '{}' does not exist in '{}'\").format(\n                        self.volume_name, volumes)\n                )\n\n            # form cmd arguments\n            project_create_cmd = [\n                os.path.join(\n                    self.wiretap_tools_dir,\n                    \"wiretap_create_node\"\n                ),\n                '-n',\n                os.path.join(\"/volumes\", self.volume_name),\n                '-d',\n                project_name,\n                '-g',\n            ]\n\n            project_create_cmd.append(self.group_name)\n\n            print(project_create_cmd)\n\n            exit_code = subprocess.call(\n                project_create_cmd,\n                cwd=os.path.expanduser('~'),\n                preexec_fn=_subprocess_preexec_fn\n            )\n\n            if exit_code != 0:\n                RuntimeError(\"Cannot create project in flame db\")\n\n            print(\n                \"A new project '{}' is created.\".format(project_name))\n        return project_exists\n\n    def _get_all_volumes(self):\n        \"\"\"Request all available volumens from WireTap\n\n        Returns:\n            list: all available volumes in server\n\n        Rises:\n            AttributeError: unable to get any volumes children from server\n        \"\"\"\n        root = WireTapNodeHandle(self._server, \"/volumes\")\n        children_num = WireTapInt(0)\n\n        get_children_num = root.getNumChildren(children_num)\n        if not get_children_num:\n            raise AttributeError(\n                \"Cannot get number of volumes: {}\".format(root.lastError())\n            )\n\n        volumes = []\n\n        # go through all children and get volume names\n        child_obj = WireTapNodeHandle()\n        for child_idx in range(children_num):\n\n            # get a child\n            if not root.getChild(child_idx, child_obj):\n                raise AttributeError(\n                    \"Unable to get child: {}\".format(root.lastError()))\n\n            node_name = WireTapStr()\n            get_children_name = child_obj.getDisplayName(node_name)\n\n            if not get_children_name:\n                raise AttributeError(\n                    \"Unable to get child name: {}\".format(\n                        child_obj.lastError())\n                )\n\n            volumes.append(node_name.c_str())\n\n        return volumes\n\n    def _user_prep(self, user_name):\n        \"\"\"Ensuring user does exists in user's stack\n\n        Args:\n            user_name (str): name of a user\n\n        Raises:\n            AttributeError: unable to create user\n        \"\"\"\n\n        # get all used usernames in db\n        used_names = self._get_usernames()\n        print(\"&gt;&gt; used_names: {}\".format(used_names))\n\n        # filter only those which are sharing input user name\n        filtered_users = [user for user in used_names if user_name in user]\n\n        if filtered_users:\n            # TODO: need to find lastly created following regex pattern for\n            # date used in name\n            return filtered_users.pop()\n\n        # create new user name with date in suffix\n        now = datetime.datetime.now()  # current date and time\n        date = now.strftime(\"%Y%m%d\")\n        new_user_name = \"{}_{}\".format(user_name, date)\n        print(new_user_name)\n\n        if not self._child_is_in_parent_path(\"/users\", new_user_name, \"USER\"):\n            # Create the new user\n            users = WireTapNodeHandle(self._server, \"/users\")\n\n            user_node = WireTapNodeHandle()\n            created_user = users.createNode(new_user_name, \"USER\", user_node)\n            if not created_user:\n                raise AttributeError(\n                    \"User {} cannot be created: {}\".format(\n                        new_user_name, users.lastError())\n                )\n\n            print(\"User `{}` is created\".format(new_user_name))\n            return new_user_name\n\n    def _get_usernames(self):\n        \"\"\"Requesting all available users from WireTap\n\n        Returns:\n            list: all available user names\n\n        Raises:\n            AttributeError: there are no users in server\n        \"\"\"\n        root = WireTapNodeHandle(self._server, \"/users\")\n        children_num = WireTapInt(0)\n\n        get_children_num = root.getNumChildren(children_num)\n        if not get_children_num:\n            raise AttributeError(\n                \"Cannot get number of volumes: {}\".format(root.lastError())\n            )\n\n        usernames = []\n\n        # go through all children and get volume names\n        child_obj = WireTapNodeHandle()\n        for child_idx in range(children_num):\n\n            # get a child\n            if not root.getChild(child_idx, child_obj):\n                raise AttributeError(\n                    \"Unable to get child: {}\".format(root.lastError()))\n\n            node_name = WireTapStr()\n            get_children_name = child_obj.getDisplayName(node_name)\n\n            if not get_children_name:\n                raise AttributeError(\n                    \"Unable to get child name: {}\".format(\n                        child_obj.lastError())\n                )\n\n            usernames.append(node_name.c_str())\n\n        return usernames\n\n    def _child_is_in_parent_path(self, parent_path, child_name, child_type):\n        \"\"\"Checking if a given child is in parent path.\n\n        Args:\n            parent_path (str): db path to parent\n            child_name (str): name of child\n            child_type (str): type of child\n\n        Raises:\n            AttributeError: Not able to get number of children\n            AttributeError: Not able to get children form parent\n            AttributeError: Not able to get children name\n            AttributeError: Not able to get children type\n\n        Returns:\n            bool: True if child is in parent path\n        \"\"\"\n        parent = WireTapNodeHandle(self._server, parent_path)\n\n        # iterate number of children\n        children_num = WireTapInt(0)\n        requested = parent.getNumChildren(children_num)\n        if not requested:\n            raise AttributeError((\n                \"Error: Cannot request number of \"\n                \"children from the node {}. Make sure your \"\n                \"wiretap service is running: {}\").format(\n                    parent_path, parent.lastError())\n            )\n\n        # iterate children\n        child_obj = WireTapNodeHandle()\n        for child_idx in range(children_num):\n            if not parent.getChild(child_idx, child_obj):\n                raise AttributeError(\n                    \"Cannot get child: {}\".format(\n                        parent.lastError()))\n\n            node_name = WireTapStr()\n            node_type = WireTapStr()\n\n            if not child_obj.getDisplayName(node_name):\n                raise AttributeError(\n                    \"Unable to get child name: %s\" % child_obj.lastError()\n                )\n            if not child_obj.getNodeTypeStr(node_type):\n                raise AttributeError(\n                    \"Unable to obtain child type: %s\" % child_obj.lastError()\n                )\n\n            if (node_name.c_str() == child_name) and (\n                    node_type.c_str() == child_type):\n                return True\n\n        return False\n\n    def _set_project_settings(self, project_name, project_data):\n        \"\"\"Setting project attributes.\n\n        Args:\n            project_name (str): name of project\n            project_data (dict): data with project attributes\n                                 (flame compatible)\n\n        Raises:\n            AttributeError: Not able to set project attributes\n        \"\"\"\n        # generated xml from project_data dict\n        _xml = \"&lt;Project&gt;\"\n        for key, value in project_data.items():\n            _xml += \"&lt;{}&gt;{}&lt;/{}&gt;\".format(key, value, key)\n        _xml += \"&lt;/Project&gt;\"\n\n        pretty_xml = minidom.parseString(_xml).toprettyxml()\n        print(\"__ xml: {}\".format(pretty_xml))\n\n        # set project data to wiretap\n        project_node = WireTapNodeHandle(\n            self._server, \"/projects/{}\".format(project_name))\n\n        if not project_node.setMetaData(\"XML\", _xml):\n            raise AttributeError(\n                \"Not able to set project attributes {}. Error: {}\".format(\n                    project_name, project_node.lastError())\n            )\n\n        print(\"Project settings successfully set.\")\n\n    def _set_project_colorspace(self, project_name, color_policy):\n        \"\"\"Set project's colorspace policy.\n\n        Args:\n            project_name (str): name of project\n            color_policy (str): name of policy\n\n        Raises:\n            RuntimeError: Not able to set colorspace policy\n        \"\"\"\n        color_policy = color_policy or \"Legacy\"\n\n        # check if the colour policy in custom dir\n        if \"/\" in color_policy:\n            # if unlikelly full path was used make it redundant\n            color_policy = color_policy.replace(\"/syncolor/policies/\", \"\")\n            # expecting input is `Shared/NameOfPolicy`\n            color_policy = \"/syncolor/policies/{}\".format(\n                color_policy)\n        else:\n            color_policy = \"/syncolor/policies/Autodesk/{}\".format(\n                color_policy)\n\n        # create arguments\n        project_colorspace_cmd = [\n            os.path.join(\n                self.wiretap_tools_dir,\n                \"wiretap_duplicate_node\"\n            ),\n            \"-s\",\n            color_policy,\n            \"-n\",\n            \"/projects/{}/syncolor\".format(project_name)\n        ]\n\n        print(project_colorspace_cmd)\n\n        exit_code = subprocess.call(\n            project_colorspace_cmd,\n            cwd=os.path.expanduser('~'),\n            preexec_fn=_subprocess_preexec_fn\n        )\n\n        if exit_code != 0:\n            RuntimeError(\"Cannot set colorspace {} on project {}\".format(\n                color_policy, project_name\n            ))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/scripts/wiretap_com.html#client.ayon_flame.api.scripts.wiretap_com.WireTapCom.__init__","title":"<code>__init__(host_name=None, volume_name=None, group_name=None)</code>","text":"<p>Initialisation of WireTap communication class</p> <p>Parameters:</p> Name Type Description Default <code>host_name</code> <code>str</code> <p>Name of host server. Defaults to None.</p> <code>None</code> <code>volume_name</code> <code>str</code> <p>Name of volume. Defaults to None.</p> <code>None</code> <code>group_name</code> <code>str</code> <p>Name of user group. Defaults to None.</p> <code>None</code> Source code in <code>client/ayon_flame/api/scripts/wiretap_com.py</code> <pre><code>def __init__(self, host_name=None, volume_name=None, group_name=None):\n    \"\"\"Initialisation of WireTap communication class\n\n    Args:\n        host_name (str, optional): Name of host server. Defaults to None.\n        volume_name (str, optional): Name of volume. Defaults to None.\n        group_name (str, optional): Name of user group. Defaults to None.\n    \"\"\"\n    # set main attributes of server\n    # if there are none set the default installation\n    self.host_name = host_name or \"localhost\"\n    self.volume_name = volume_name or \"stonefs\"\n    self.group_name = group_name or \"staff\"\n\n    # wiretap tools dir path\n    self.wiretap_tools_dir = os.getenv(\"AYON_WIRETAP_TOOLS\")\n\n    # initialize WireTap client\n    WireTapClientInit()\n\n    # add the server to shared variable\n    self._server = WireTapServerHandle(\"{}:IFFFS\".format(self.host_name))\n    print(\"WireTap connected at '{}'...\".format(\n        self.host_name))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/api/scripts/wiretap_com.html#client.ayon_flame.api.scripts.wiretap_com.WireTapCom.get_launch_args","title":"<code>get_launch_args(project_name, project_data, user_name, *args, **kwargs)</code>","text":"<p>Forming launch arguments for AYON launcher.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of project</p> required <code>project_data</code> <code>dict</code> <p>Flame compatible project data</p> required <code>user_name</code> <code>str</code> <p>name of user</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>arguments</p> Source code in <code>client/ayon_flame/api/scripts/wiretap_com.py</code> <pre><code>def get_launch_args(\n        self, project_name, project_data, user_name, *args, **kwargs):\n    \"\"\"Forming launch arguments for AYON launcher.\n\n    Args:\n        project_name (str): name of project\n        project_data (dict): Flame compatible project data\n        user_name (str): name of user\n\n    Returns:\n        list: arguments\n    \"\"\"\n\n    workspace_name = kwargs.get(\"workspace_name\")\n    color_policy = kwargs.get(\"color_policy\")\n\n    project_exists = self._project_prep(project_name)\n    if not project_exists:\n        self._set_project_settings(project_name, project_data)\n        self._set_project_colorspace(project_name, color_policy)\n\n    launch_args = [\n        \"--start-project={}\".format(project_name),\n        \"--create-workspace\",\n    ]\n\n    # user profiles have been removed in flame 2025\n    if self._get_flame_year() &lt; 2025:\n        user_name = self._user_prep(user_name)\n        launch_args.append(\"--start-user={}\".format(user_name))\n\n    if workspace_name is None:\n        # default workspace\n        print(\"Using a default workspace\")\n        return launch_args\n\n    else:\n        print(\n            \"Using a custom workspace '{}'\".format(workspace_name))\n\n        self._workspace_prep(project_name, workspace_name)\n        launch_args.append(\"--start-workspace={}\".format(workspace_name))\n        return launch_args\n</code></pre>"},{"location":"autoapi/client/ayon_flame/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_flame/hooks/pre_flame_setup.html","title":"pre_flame_setup","text":""},{"location":"autoapi/client/ayon_flame/hooks/pre_flame_setup.html#client.ayon_flame.hooks.pre_flame_setup.FlamePrelaunch","title":"<code>FlamePrelaunch</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Flame prelaunch hook</p> <p>Will make sure flame_script_dirs are copied to user's folder defined in environment var FLAME_SCRIPT_DIR.</p> Source code in <code>client/ayon_flame/hooks/pre_flame_setup.py</code> <pre><code>class FlamePrelaunch(PreLaunchHook):\n    \"\"\" Flame prelaunch hook\n\n    Will make sure flame_script_dirs are copied to user's folder defined\n    in environment var FLAME_SCRIPT_DIR.\n    \"\"\"\n    app_groups = {\"flame\"}\n    order = 1\n    permissions = 0o777\n\n    wtc_script_path = os.path.join(\n        FLAME_ADDON_ROOT, \"api\", \"scripts\", \"wiretap_com.py\"\n    )\n    launch_types = {LaunchTypes.local}\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.signature = \"( {} )\".format(self.__class__.__name__)\n\n    def execute(self):\n        _env = self.launch_context.env\n        ayon_root = os.path.dirname(os.environ[\"AYON_EXECUTABLE\"])\n        _env[\"PATH\"] = os.pathsep.join([\n            path\n            for path in _env[\"PATH\"].split(os.pathsep)\n            if not path.startswith(ayon_root)\n        ])\n\n        self.flame_python_exe = _env[\"AYON_FLAME_PYTHON_EXEC\"]\n\n        # add it to data for other hooks\n        self.data[\"flame_python_executable\"] = self.flame_python_exe\n\n        self.flame_pythonpath = _env[\"AYON_FLAME_PYTHONPATH\"]\n\n        \"\"\"Hook entry method.\"\"\"\n        project_entity = self.data[\"project_entity\"]\n        project_name = project_entity[\"name\"]\n        volume_name = _env.get(\"FLAME_WIRETAP_VOLUME\")\n\n        # get image io\n        project_settings = self.data[\"project_settings\"]\n\n        imageio_flame = project_settings[\"flame\"][\"imageio\"]\n\n        # Check whether 'enabled' key from host imageio settings exists\n        # so we can tell if host is using the new colormanagement framework.\n        # If the 'enabled' isn't found we want 'colormanaged' set to True\n        # because prior to the key existing we always did colormanagement for\n        # Flame\n        colormanaged = imageio_flame.get(\"enabled\")\n        # if key was not found, set to True\n        # ensuring backward compatibility\n        if colormanaged is None:\n            colormanaged = True\n\n        # get user name and host name\n        user_name = get_ayon_username()\n        user_name = user_name.replace(\".\", \"_\")\n\n        hostname = socket.gethostname()  # not returning wiretap host name\n\n        self.log.debug(\"Collected user \\\"{}\\\"\".format(user_name))\n        self.log.info(pformat(project_entity))\n        project_attribs = project_entity[\"attrib\"]\n        width = project_attribs[\"resolutionWidth\"]\n        height = project_attribs[\"resolutionHeight\"]\n        fps = float(project_attribs[\"fps\"])\n\n        project_data = {\n            \"Name\": project_entity[\"name\"],\n            \"Nickname\": project_entity[\"code\"],\n            \"Description\": \"Created by AYON\",\n            \"SetupDir\": project_entity[\"name\"],\n            \"FrameWidth\": int(width),\n            \"FrameHeight\": int(height),\n            \"AspectRatio\": float(\n                (width / height) * project_attribs[\"pixelAspect\"]\n            ),\n            \"FrameRate\": self._get_flame_fps(fps)\n        }\n\n        data_to_script = {\n            # from settings\n            \"host_name\": _env.get(\"FLAME_WIRETAP_HOSTNAME\") or hostname,\n            \"volume_name\": volume_name,\n            \"group_name\": _env.get(\"FLAME_WIRETAP_GROUP\"),\n\n            # from project\n            \"project_name\": project_name,\n            \"user_name\": user_name,\n            \"project_data\": project_data\n        }\n\n        # add color management data\n        if colormanaged:\n            project_data.update({\n                \"FrameDepth\": str(imageio_flame[\"project\"][\"frameDepth\"]),\n                \"FieldDominance\": str(\n                    imageio_flame[\"project\"][\"fieldDominance\"])\n            })\n            data_to_script[\"color_policy\"] = str(\n                imageio_flame[\"project\"][\"colourPolicy\"])\n\n        self.log.info(pformat(dict(_env)))\n        self.log.info(pformat(data_to_script))\n\n        app_arguments = self._get_launch_arguments(data_to_script)\n\n        # fix project data permission issue\n        self._fix_permissions(project_name, volume_name)\n\n        self.launch_context.launch_args.extend(app_arguments)\n\n    def _fix_permissions(self, project_name, volume_name):\n        \"\"\"Work around for project data permissions\n\n        Reported issue: when project is created locally on one machine,\n        it is impossible to migrate it to other machine. Autodesk Flame\n        is crating some unmanagable files which needs to be opened to 0o777.\n\n        Args:\n            project_name (str): project name\n            volume_name (str): studio volume\n        \"\"\"\n        dirs_to_modify = [\n            \"/usr/discreet/project/{}\".format(project_name),\n            \"/opt/Autodesk/clip/{}/{}.prj\".format(volume_name, project_name),\n            \"/usr/discreet/clip/{}/{}.prj\".format(volume_name, project_name)\n        ]\n\n        for dirtm in dirs_to_modify:\n            for root, dirs, files in os.walk(dirtm):\n                try:\n                    for name in set(dirs) | set(files):\n                        path = os.path.join(root, name)\n                        st = os.stat(path)\n                        if oct(st.st_mode) != self.permissions:\n                            os.chmod(path, self.permissions)\n\n                except OSError as exc:\n                    self.log.warning(\"Not able to open files: {}\".format(exc))\n\n    def _get_flame_fps(self, fps_num):\n        fps_table = {\n            float(23.976): \"23.976 fps\",\n            int(25): \"25 fps\",\n            int(24): \"24 fps\",\n            float(29.97): \"29.97 fps DF\",\n            int(30): \"30 fps\",\n            int(50): \"50 fps\",\n            float(59.94): \"59.94 fps DF\",\n            int(60): \"60 fps\"\n        }\n\n        match_key = min(fps_table.keys(), key=lambda x: abs(x - fps_num))\n\n        try:\n            return fps_table[match_key]\n        except KeyError as msg:\n            raise KeyError((\n                \"Missing FPS key in conversion table. \"\n                \"Following keys are available: {}\".format(fps_table.keys())\n            )) from msg\n\n    def _add_pythonpath(self, env):\n        pythonpath = env.get(\"PYTHONPATH\")\n\n        # separate it explicitly by `;` that is what we use in settings\n        new_pythonpath = self.flame_pythonpath.split(os.pathsep)\n        new_pythonpath += pythonpath.split(os.pathsep)\n\n        env[\"PYTHONPATH\"] = os.pathsep.join(new_pythonpath)\n\n    def _get_launch_arguments(self, script_data):\n        # Dump data to string\n        dumped_script_data = json.dumps(script_data)\n\n        with make_temp_file(dumped_script_data) as tmp_json_path:\n            # Prepare subprocess arguments\n            env = self.launch_context.env.copy()\n            self._add_pythonpath(env)\n            args = [\n                self.flame_python_exe.format(**env),\n                self.wtc_script_path,\n                tmp_json_path\n            ]\n            self.log.info(\"Executing: {}\".format(\" \".join(args)))\n\n            process_kwargs = {\n                \"logger\": self.log,\n                \"env\": env\n            }\n\n            run_subprocess(args, **process_kwargs)\n\n            # process returned json file to pass launch args\n            return_json_data = open(tmp_json_path).read()\n            returned_data = json.loads(return_json_data)\n            app_args = returned_data.get(\"app_args\")\n            self.log.info(\"____ app_args: `{}`\".format(app_args))\n\n            if not app_args:\n                RuntimeError(\"App arguments were not solved\")\n\n        return app_args\n</code></pre>"},{"location":"autoapi/client/ayon_flame/hooks/pre_opentimelineio_install.html","title":"pre_opentimelineio_install","text":""},{"location":"autoapi/client/ayon_flame/hooks/pre_opentimelineio_install.html#client.ayon_flame.hooks.pre_opentimelineio_install.InstallOpenTimelineIOToFlame","title":"<code>InstallOpenTimelineIOToFlame</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically install OpenTimelineIO to Flame python environment.</p> Source code in <code>client/ayon_flame/hooks/pre_opentimelineio_install.py</code> <pre><code>class InstallOpenTimelineIOToFlame(PreLaunchHook):\n    \"\"\"Automatically install OpenTimelineIO to Flame python environment.\"\"\"\n\n    app_groups = {\"flame\"}\n    order = 2\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Prelaunch hook is not crucial\n        try:\n            settings = self.data[\"project_settings\"][\"flame\"]\n            hook_settings = settings[\"hooks\"][\"InstallOpenTimelineIOToFlame\"]\n            if not hook_settings[\"enabled\"]:\n                return\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                f\"Processing of '{self.__class__.__name__}' crashed.\",\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        self.log.debug(\"Check for OpenTimelineIO installation.\")\n\n        flame_py_exe = self.data.get(\"flame_python_executable\")\n        if not flame_py_exe:\n            self.log.warning(\"Flame python executable not found.\")\n            return\n\n        env = self.launch_context.env\n        # first try if OpenTimeline is installed into Flame python environment\n        result = subprocess.run(\n            [flame_py_exe, \"-c\", \"import opentimelineio\"], env=env\n        )\n        if result.returncode == 0:\n            self.log.info(\"OpenTimelineIO is installed within Flame env.\")\n            return\n\n        # secondly if OpenTimelineIO is installed in our custom site-packages\n        custom_site_path = self.get_custom_site_path()\n\n        # make sure the custom site-packages exists\n        os.makedirs(custom_site_path, exist_ok=True)\n\n        # add custom site-packages to PYTHONPATH\n        env[\"PYTHONPATH\"] += f\"{os.pathsep}{custom_site_path}\"\n        result = subprocess.run(\n            [flame_py_exe, \"-c\", \"import opentimelineio\"], env=env\n        )\n        if result.returncode == 0:\n            self.log.info(\n                \"OpenTimelineIO is installed within AYON Flame env.\")\n            return\n\n        # lastly install OpenTimelineIO into our custom site-packages\n        result = subprocess.run(\n            [\n                flame_py_exe,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"opentimelineio\",\n                \"-t\",\n                custom_site_path,\n            ]\n        )\n        if result.returncode == 0:\n            self.log.info(\n                \"OpenTimelineIO is installed now within AYON Flame \"\n                \"env and ready to be used.\"\n            )\n            return\n\n        raise ApplicationLaunchFailed(\"Failed to install OpenTimelineIO\")\n\n    def get_custom_site_path(self):\n        return appdirs.user_data_dir(\"ayon_flame\", \"Ynput\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/otio/index.html","title":"otio","text":""},{"location":"autoapi/client/ayon_flame/otio/flame_export.html","title":"flame_export","text":"<p>compatibility OpenTimelineIO 0.12.0 and newer</p>"},{"location":"autoapi/client/ayon_flame/otio/flame_export.html#client.ayon_flame.otio.flame_export.create_otio_reference","title":"<code>create_otio_reference(clip_data, media_info=None, fps=None)</code>","text":"<p>Create an OTIO reference from Flame clip data.</p> <p>Parameters:</p> Name Type Description Default <code>clip_data</code> <code>dict</code> <p>Flame clip data.</p> required <code>media_info</code> <code>Optional[MediaInfoFile]</code> <p>Media information.</p> <code>None</code> <code>fps</code> <code>Optional[float]</code> <p>Frames per second.</p> <code>None</code> <p>Returns:</p> Type Description <code>ExternalReference | ImageSequenceReference | MissingReference</code> <p>otio.schema.ExternalReference |</p> <code>ExternalReference | ImageSequenceReference | MissingReference</code> <p>otio.schema.ImageSequenceReference |</p> <code>ExternalReference | ImageSequenceReference | MissingReference</code> <p>otio.schema.MissingReference: OTIO reference.</p> Source code in <code>client/ayon_flame/otio/flame_export.py</code> <pre><code>def create_otio_reference(\n        clip_data: dict,\n        media_info: MediaInfoFile | None = None,\n        fps: float | None = None\n) -&gt; (\n    otio.schema.ExternalReference |\n    otio.schema.ImageSequenceReference |\n    otio.schema.MissingReference\n):\n    \"\"\"Create an OTIO reference from Flame clip data.\n\n    Args:\n        clip_data (dict): Flame clip data.\n        media_info (Optional[MediaInfoFile]): Media information.\n        fps (Optional[float]): Frames per second.\n\n    Returns:\n        otio.schema.ExternalReference |\n        otio.schema.ImageSequenceReference |\n        otio.schema.MissingReference: OTIO reference.\n    \"\"\"\n    if not media_info:\n        log.error(\"Media info is missing\")\n        return otio.schema.MissingReference(\n            name=clip_data[\"segment_name\"]\n        )\n\n    metadata = _get_metadata(clip_data)\n\n    # Add image-based metadata if not a pure audio media\n    # TODO: what happens if media is image-based but not width\n    # can be reached ?\n    # (could use ayon_core.lib.transcoding.get_otio_info_for_input)\n    if hasattr(media_info, \"width\"):\n        metadata.update(\n            {\n                \"ayon.source.width\": media_info.width,\n                \"ayon.source.height\": media_info.height,\n                \"ayon.source.pixelAspect\": media_info.pixel_aspect,\n            }\n        )\n\n    duration = int(clip_data[\"source_duration\"])\n\n    # get file info for path and start frame\n    media_start = media_info.start_frame or 0\n    fps = fps or media_info.fps or OtioExportCTX.get_fps()\n\n    path = clip_data[\"fpath\"]\n\n    file_name = os.path.basename(path)\n    file_head, extension = os.path.splitext(file_name)\n\n    # get padding and other file infos\n    log.debug(f\"_ path: {path}\")\n\n    otio_ex_ref_item = None\n\n    sequence_match = re.match(\n        # match range pattern e.g. \"foo_[1001-1010].ext\"\n        r\".*\\[(?P&lt;start_frame&gt;\\d*)-(?P&lt;end_frame&gt;\\d*)\\].?\",\n        media_info.file_pattern\n    )\n\n    if sequence_match:\n        frame_number = sequence_match.group(\"start_frame\")\n        file_head = file_name.split(frame_number)[0]\n        start_frame = int(frame_number)\n        padding = len(frame_number)\n\n        metadata.update({\n            \"isSequence\": True,\n            \"padding\": padding\n        })\n\n        # if it is file sequence try to create `ImageSequenceReference`\n        # the OTIO might not be compatible so return nothing and do it old way\n        try:\n            dirname = os.path.dirname(path)\n            otio_ex_ref_item = otio.schema.ImageSequenceReference(\n                target_url_base=dirname + os.sep,\n                name_prefix=file_head,\n                name_suffix=extension,\n                start_frame=start_frame,\n                frame_zero_padding=padding,\n                rate=fps,\n                available_range=create_otio_time_range(\n                    media_start,\n                    duration,\n                    fps\n                )\n            )\n\n        # in case old OTIO create sequence as `ExternalReference`\n        except AttributeError:\n            dirname, file_name = os.path.split(path)\n            file_name = utils.get_reformatted_filename(file_name, padded=False)\n            reformated_path = os.path.join(dirname, file_name)\n            otio_ex_ref_item = otio.schema.ExternalReference(\n                target_url=reformated_path,\n                available_range=create_otio_time_range(\n                    media_start,\n                    duration,\n                    fps\n                )\n            )\n\n    # video/audio file create `ExternalReference`\n    else:\n        otio_ex_ref_item = otio.schema.ExternalReference(\n            target_url=path,\n            available_range=create_otio_time_range(\n                media_start,\n                duration,\n                fps\n            )\n        )\n\n    # add metadata to otio item\n    add_otio_metadata(otio_ex_ref_item, clip_data, **metadata)\n\n    return otio_ex_ref_item\n</code></pre>"},{"location":"autoapi/client/ayon_flame/otio/tw_bake.html","title":"tw_bake","text":"<p>The following code is based on https://github.com/talosh/flameTimewarpML/blob/main/pytorch/flameTimewarpML_inference.py</p> <p>It allows to \"bake\" or \"plot\" the curve values from a Timewarp saved setup.</p> <p>Speed animated timewarp are known to be less accurate, worth suggesting to the clients to avoid them.</p>"},{"location":"autoapi/client/ayon_flame/otio/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_flame/otio/utils.html#client.ayon_flame.otio.utils.get_frame_from_filename","title":"<code>get_frame_from_filename(filename)</code>","text":"<p>Return sequence number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Type Description <p>Optional[str]: sequence frame number if found or None</p> Example <p>def get_frame_from_filename(path):     (\"plate.0001.exr\") &gt; \"0001\"</p> Source code in <code>client/ayon_flame/otio/utils.py</code> <pre><code>def get_frame_from_filename(filename):\n    \"\"\"\n    Return sequence number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        Optional[str]: sequence frame number if found or None\n\n    Example:\n        def get_frame_from_filename(path):\n            (\"plate.0001.exr\") &gt; \"0001\"\n\n    \"\"\"\n    _, ext = os.path.splitext(filename)\n\n    if ext.lower() not in IMAGE_EXTENSIONS:\n        return None\n\n    pattern = re.compile(FRAME_PATTERN + re.escape(ext))\n    found = pattern.findall(filename)\n\n    return found.pop() if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/otio/utils.html#client.ayon_flame.otio.utils.get_marker_from_clip_index","title":"<code>get_marker_from_clip_index(otio_timeline, clip_index)</code>","text":"<p>Return the clip and marker data from clip index.</p> <p>Parameters:</p> Name Type Description Default <code>otio_timeline</code> <code>dict</code> <p>otio timeline</p> required <code>clip_index</code> <code>str</code> <p>The clip index.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>otio clip object</p> Source code in <code>client/ayon_flame/otio/utils.py</code> <pre><code>def get_marker_from_clip_index(otio_timeline, clip_index):\n    \"\"\"\n    Return the clip and marker data from clip index.\n\n    Args:\n        otio_timeline (dict): otio timeline\n        clip_index (str): The clip index.\n\n    Returns:\n        dict: otio clip object\n\n    \"\"\"\n    import ayon_flame.api as ayfapi\n\n    for otio_clip in otio_timeline.find_clips():\n\n        # Retrieve otioClip from parent context otioTimeline\n        # See collect_current_project\n        for marker in otio_clip.markers:\n\n            if ayfapi.MARKER_NAME not in marker.name:\n                continue\n\n            if marker.metadata.get(\"clip_index\") == clip_index:\n                return otio_clip, marker\n\n    return None, None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/otio/utils.html#client.ayon_flame.otio.utils.get_padding_from_filename","title":"<code>get_padding_from_filename(filename)</code>","text":"<p>Return padding number from Flame path style</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>padding number</p> Example <p>get_padding_from_filename(\"plate.0001.exr\") &gt; 4</p> Source code in <code>client/ayon_flame/otio/utils.py</code> <pre><code>def get_padding_from_filename(filename):\n    \"\"\"\n    Return padding number from Flame path style\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        int: padding number\n\n    Example:\n        get_padding_from_filename(\"plate.0001.exr\") &gt; 4\n\n    \"\"\"\n    found = get_frame_from_filename(filename)\n\n    return len(found) if found else None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/otio/utils.html#client.ayon_flame.otio.utils.get_reformatted_filename","title":"<code>get_reformatted_filename(filename, padded=True)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_flame/otio/utils.py</code> <pre><code>def get_reformatted_filename(filename, padded=True):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        filename (str): file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformatted_filename(\"plate.1001.exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    found = FRAME_PATTERN.search(filename)\n\n    if not found:\n        log.info(\"File name is not sequence: {}\".format(filename))\n        return filename\n\n    padding = get_padding_from_filename(filename)\n\n    replacement = \"%0{}d\".format(padding) if padded else \"%d\"\n    start_idx, end_idx = found.span(1)\n\n    return replacement.join(\n        [filename[:start_idx], filename[end_idx:]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_flame/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html","title":"create_shot_clip","text":""},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.CreateShotClip","title":"<code>CreateShotClip</code>","text":"<p>               Bases: <code>FlameCreator</code></p> <p>Publishable clip</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>class CreateShotClip(plugin.FlameCreator):\n    \"\"\"Publishable clip\"\"\"\n\n    identifier = \"io.ayon.creators.flame.clip\"\n    label = \"Create Publishable Clip\"\n    product_type = \"editorial\"\n    product_base_type = \"editorial\"\n    icon = \"film\"\n    defaults = [\"Main\"]\n\n    detailed_description = \"\"\"\nPublishing clips/plate, audio for new shots to project\nor updating already created from Flame. Publishing will create\nOTIO file.\n\"\"\"\n\n    create_allow_thumbnail = False\n\n    shot_instances = {}\n\n    # Pre-create attribute keys that can be hidden/shown via settings\n    overridable_attributes = {\n        \"hierarchy\",\n        \"useShotName\",\n        \"clipRename\",\n        \"clipName\",\n        \"segmentIndex\",\n        \"countFrom\",\n        \"countSteps\",\n        \"folder\",\n        \"episode\",\n        \"sequence\",\n        \"track\",\n        \"shot\",\n        \"export_audio\",\n        \"sourceResolution\",\n        \"vSyncOn\",\n        \"vSyncTrack\",\n        \"workfileFrameStart\",\n        \"handleStart\",\n        \"handleEnd\",\n        \"includeHandles\",\n        \"retimedHandles\",\n        \"retimedFramerange\",\n    }\n\n    def get_pre_create_attr_defs(self):\n\n        def header_label(text):\n            return f\"&lt;br&gt;&lt;b&gt;{text}&lt;/b&gt;\"\n\n        tokens_help = \"\"\"\\nUsable tokens:\n    {_clip_}: name of used clip\n    {_track_}: name of parent track layer\n    {_sequence_}: name of parent sequence (timeline)\"\"\"\n\n        current_sequence = lib.get_current_sequence(lib.CTX.selection)\n        if current_sequence is not None:\n            gui_tracks = [\n                {\"value\": tr_name, \"label\": f\"Track: {tr_name}\"}\n                for tr_name in get_video_track_names(current_sequence)\n            ]\n        else:\n            gui_tracks = []\n\n        # Project settings might be applied to this creator via\n        # the inherited `Creator.apply_settings`\n        presets = self.presets\n\n        attr_defs = [\n            BoolDef(\"use_selection\",\n                    label=\"Use only selected clip(s).\",\n                    tooltip=(\n                        \"When enabled it restricts create process \"\n                        \"to selected clips.\"\n                    ),\n                    default=True),\n\n            # renameHierarchy\n            UILabelDef(\n                label=header_label(\"Shot Hierarchy And Rename Settings\")\n            ),\n            TextDef(\n                \"hierarchy\",\n                label=\"Shot Parent Hierarchy\",\n                tooltip=\"Parents folder for shot root folder, \"\n                        \"Template filled with *Hierarchy Data* section\",\n                default=presets.get(\"hierarchy\", \"{folder}/{sequence}\"),\n            ),\n            BoolDef(\n                \"useShotName\",\n                label=\"Use shot name\",\n                tooltip=\"Use name form Shot name clip attribute.\",\n                default=presets.get(\"useShotName\", True),\n            ),\n            BoolDef(\n                \"clipRename\",\n                label=\"Rename clips\",\n                tooltip=\"Renaming selected clips on fly\",\n                default=presets.get(\"clipRename\", False),\n            ),\n            TextDef(\n                \"clipName\",\n                label=\"Clip Name Template\",\n                tooltip=\"template for creating shot names, used for \"\n                        \"renaming (use rename: on)\",\n                default=presets.get(\"clipName\", \"{sequence}{shot}\"),\n            ),\n            BoolDef(\n                \"segmentIndex\",\n                label=\"Segment Index\",\n                tooltip=\"Take number from segment index\",\n                default=presets.get(\"segmentIndex\", True),\n            ),\n            NumberDef(\n                \"countFrom\",\n                label=\"Count sequence from\",\n                tooltip=\"Set where the sequence number starts from\",\n                default=presets.get(\"countFrom\", 10),\n            ),\n            NumberDef(\n                \"countSteps\",\n                label=\"Stepping number\",\n                tooltip=\"What number is adding every new step\",\n                default=presets.get(\"countSteps\", 10),\n            ),\n\n            # hierarchyData\n            UILabelDef(\n                label=header_label(\"Shot Template Keywords\")\n            ),\n            TextDef(\n                \"folder\",\n                label=\"{folder}\",\n                tooltip=\"Name of folder used for root of generated shots.\\n\"\n                        f\"{tokens_help}\",\n                default=presets.get(\"folder\", \"shots\"),\n            ),\n            TextDef(\n                \"episode\",\n                label=\"{episode}\",\n                tooltip=f\"Name of episode.\\n{tokens_help}\",\n                default=presets.get(\"episode\", \"ep01\"),\n            ),\n            TextDef(\n                \"sequence\",\n                label=\"{sequence}\",\n                tooltip=f\"Name of sequence of shots.\\n{tokens_help}\",\n                default=presets.get(\"sequence\", \"sq01\"),\n            ),\n            TextDef(\n                \"track\",\n                label=\"{track}\",\n                tooltip=f\"Name of timeline track.\\n{tokens_help}\",\n                default=presets.get(\"track\", \"{_track_}\"),\n            ),\n            TextDef(\n                \"shot\",\n                label=\"{shot}\",\n                tooltip=\"Name of shot. '#' is converted to padded number.\"\n                        f\"\\n{tokens_help}\",\n                default=presets.get(\"shot\", \"sh###\"),\n            ),\n\n            # verticalSync\n            UILabelDef(\n                label=header_label(\"Vertical Synchronization Of Attributes\")\n            ),\n            BoolDef(\n                \"vSyncOn\",\n                label=\"Enable Vertical Sync\",\n                tooltip=\"Switch on if you want clips above \"\n                        \"each other to share its attributes\",\n                default=presets.get(\"vSyncOn\", True),\n            ),\n            EnumDef(\n                \"vSyncTrack\",\n                label=\"Hero track\",\n                tooltip=\"Select driving track name which should \"\n                        \"be mastering all others\",\n                items=gui_tracks or [\"&lt;nothing to select&gt;\"],\n            ),\n\n            # publishSettings\n            UILabelDef(\n                label=header_label(\"Publish Settings\")\n            ),\n            EnumDef(\n                \"clipVariant\",\n                label=\"Product Variant\",\n                tooltip=\"Chose variant which will be then used for \"\n                        \"product name, if &lt;track_name&gt; \"\n                        \"is selected, name of track layer will be used\",\n                items=['&lt;track_name&gt;', 'main', 'bg', 'fg', 'bg', 'animatic'],\n            ),\n            EnumDef(\n                \"productType\",\n                label=\"Product Type\",\n                tooltip=\"How the product will be used\",\n                items=['plate', 'take'],\n            ),\n            EnumDef(\n                \"reviewableSource\",\n                label=\"Reviewable Source\",\n                tooltip=\"Select source for reviewable files.\",\n                items=[\n                    {\"value\": None, \"label\": \"&lt; none &gt;\"},\n                    {\"value\": \"clip_media\", \"label\": \"[ Clip's media ]\"},\n                ]\n                + gui_tracks,\n            ),\n            BoolDef(\n                \"export_audio\",\n                label=\"Include audio\",\n                tooltip=\"Process subsets with corresponding audio\",\n                default=presets.get(\"export_audio\", False),\n            ),\n            BoolDef(\n                \"sourceResolution\",\n                label=\"Source resolution\",\n                tooltip=\"Is resolution taken from timeline or source?\",\n                default=presets.get(\"sourceResolution\", False),\n            ),\n\n            # shotAttr\n            UILabelDef(\n                label=header_label(\"Shot Attributes\"),\n            ),\n            NumberDef(\n                \"workfileFrameStart\",\n                label=\"Workfiles Start Frame\",\n                tooltip=\"Set workfile starting frame number\",\n                default=presets.get(\"workfileFrameStart\", 1001),\n            ),\n            NumberDef(\n                \"handleStart\",\n                label=\"Handle start (head)\",\n                tooltip=\"Handle at start of clip\",\n                default=presets.get(\"handleStart\", 0),\n            ),\n            NumberDef(\n                \"handleEnd\",\n                label=\"Handle end (tail)\",\n                tooltip=\"Handle at end of clip\",\n                default=presets.get(\"handleEnd\", 0),\n            ),\n            BoolDef(\n                \"includeHandles\",\n                label=\"Include handles\",\n                tooltip=\"Should the handles be included?\",\n                default=presets.get(\"includeHandles\", True),\n            ),\n            BoolDef(\n                \"retimedHandles\",\n                label=\"Retimed handles\",\n                tooltip=\"Should the handles be retimed?\",\n                default=presets.get(\"retimedHandles\", True),\n            ),\n            BoolDef(\n                \"retimedFramerange\",\n                label=\"Retimed framerange\",\n                tooltip=\"Should the framerange be retimed?\",\n                default=presets.get(\"retimedFramerange\", True),\n            ),\n        ]\n\n        disabled_attributes = self._get_disabled_attributes()\n        return [\n            attr_def for attr_def in attr_defs\n\n            # include only if enabled as overridable in settings when\n            # the attribute is overridable\n            if attr_def.key not in disabled_attributes\n        ]\n\n    def _get_disabled_attributes(self) -&gt; set[str]:\n        \"\"\"Return pre-create attribute definition keys that are not exposed\n        for editing to the user.\"\"\"\n        # Filter out those that are not enabled based on the filter state\n        enabled_overrides: set[str] = set(self.presets[\"overrides\"])\n        if \"vSyncOn\" in enabled_overrides or self.presets.get(\"vSyncOn\"):\n            enabled_overrides.add(\"vSyncTrack\")\n\n        return {\n            attr for attr in self.overridable_attributes\n            if attr not in enabled_overrides\n        }\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Ensure to include the default values for excluded attributes that\n        # are marked not overridable in settings into the pre_create_data\n        for attr in self._get_disabled_attributes():\n            if attr in self.presets:\n                pre_create_data[attr] = self.presets[attr]\n\n        super().create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        if len(self.selected) &lt; 1:\n            return\n\n        self.log.info(self.selected)\n        self.log.debug(f\"Selected: {self.selected}\")\n\n        audio_clips = [\n            audio_track.selected_segments\n            for audio_track in self.sequence.audio_tracks\n        ]\n\n        if not any(audio_clips) and pre_create_data.get(\"export_audio\"):\n            raise CreatorError(\n                \"You must have audio in your active \"\n                \"timeline in order to export audio.\"\n            )\n\n        instance_data.update(pre_create_data)\n        instance_data[\"task\"] = None\n\n        # sort selected trackItems by\n        v_sync_track = pre_create_data.get(\"vSyncTrack\", \"\")\n\n        # sort selected trackItems by\n        sorted_selected_segments = []\n        unsorted_selected_segments = []\n        for _segment in self.selected:\n            if _segment.parent.name.get_value() in v_sync_track:\n                sorted_selected_segments.append(_segment)\n            else:\n                unsorted_selected_segments.append(_segment)\n\n        sorted_selected_segments.extend(unsorted_selected_segments)\n\n        # detect enabled creators for review, plate and audio\n        shot_creator_id = \"io.ayon.creators.flame.shot\"\n        plate_creator_id = \"io.ayon.creators.flame.plate\"\n        audio_creator_id = \"io.ayon.creators.flame.audio\"\n        all_creators = {\n            shot_creator_id: True,\n            plate_creator_id: True,\n            audio_creator_id: True,\n        }\n        instances = []\n\n        for idx, segment in enumerate(sorted_selected_segments):\n\n            clip_index = str(uuid.uuid4())\n            segment_instance_data = deepcopy(instance_data)\n            segment_instance_data[\"clip_index\"] = clip_index\n\n            # convert track item to timeline media pool item\n            publish_clip = ayfapi.PublishableClip(\n                segment,\n                log=self.log,\n                pre_create_data=pre_create_data,\n                data=segment_instance_data,\n                product_type=self.product_type,\n                rename_index=idx,\n            )\n\n            segment = publish_clip.convert()\n            if segment is None:\n                # Ignore input clips that do not convert into a track item\n                # from `PublishableClip.convert`\n                continue\n\n            segment_instance_data.update(publish_clip.marker_data)\n            self.log.info(\n                \"Processing track item data: {} (index: {})\".format(\n                    segment, idx)\n            )\n\n            # Delete any existing instances previously generated for the clip.\n            prev_tag_data = lib.get_segment_data_marker(segment)\n            if prev_tag_data:\n                for creator_id, inst_data in prev_tag_data.get(\n                        _CONTENT_ID, {}).items():\n                    creator = self.create_context.creators[creator_id]\n                    prev_instance = self.create_context.instances_by_id.get(\n                        inst_data[\"instance_id\"]\n                    )\n                    if prev_instance is not None:\n                        creator.remove_instances([prev_instance])\n\n            # Create new product(s) instances.\n            clip_instances = {}\n            # disable shot creator if heroTrack is not enabled\n            all_creators[shot_creator_id] = segment_instance_data.get(\n                \"heroTrack\", False)\n            # disable audio creator if audio is not enabled\n            all_creators[audio_creator_id] = (\n                segment_instance_data.get(\"heroTrack\", False) and\n                pre_create_data.get(\"export_audio\", False)\n            )\n\n            enabled_creators = tuple(\n                cre for cre, enabled in all_creators.items() if enabled)\n            clip_instances = {}\n            shot_folder_path = segment_instance_data[\"folderPath\"]\n            shot_instances = self.shot_instances.setdefault(\n                shot_folder_path, {})\n\n            for creator_id in enabled_creators:\n                creator = self.create_context.creators[creator_id]\n                sub_instance_data = deepcopy(segment_instance_data)\n                creator_attributes = sub_instance_data.setdefault(\n                    \"creator_attributes\", {}\n                )\n                shot_folder_path = sub_instance_data[\"folderPath\"]\n\n                # Shot creation\n                if creator_id == shot_creator_id:\n                    segment_data = lib.get_segment_attributes(segment)\n                    self.log.debug(f\"segment_data: '{segment_data}'\")\n                    record_in = segment_data[\"record_in\"]\n                    record_out = segment_data[\"record_out\"]\n                    segment_duration = segment_data.get(\"record_duration\")\n                    if segment_duration is None:\n                        segment_duration = record_out - record_in + 1\n                    workfileFrameStart = sub_instance_data[\n                        \"workfileFrameStart\"]\n                    sub_instance_data.update(\n                        {\n                            \"variant\": \"main\",\n                            \"productType\": \"shot\",\n                            \"productBaseType\": \"shot\",\n                            \"productName\": \"shotMain\",\n                            \"creator_attributes\": {\n                                \"workfileFrameStart\": workfileFrameStart,\n                                \"handleStart\": sub_instance_data[\n                                    \"handleStart\"],\n                                \"handleEnd\": sub_instance_data[\"handleEnd\"],\n                                \"frameStart\": workfileFrameStart,\n                                \"frameEnd\": (\n                                    workfileFrameStart + segment_duration),\n                                \"clipIn\": int(record_in),\n                                \"clipOut\": int(record_out),\n                                \"clipDuration\": segment_duration,\n                                \"sourceIn\": int(segment_data[\"source_in\"]),\n                                \"sourceOut\": int(segment_data[\"source_out\"]),\n                                \"includeHandles\": pre_create_data[\n                                    \"includeHandles\"],\n                                \"retimedHandles\": pre_create_data[\n                                    \"retimedHandles\"],\n                                \"retimedFramerange\": pre_create_data[\n                                    \"retimedFramerange\"\n                                ],\n                                \"useSourceResolution\": sub_instance_data[\n                                    \"sourceResolution\"],\n                            },\n                            \"label\": f\"{shot_folder_path} shot\",\n                        }\n                    )\n\n                # Plate,\n                # insert parent instance data to allow\n                # metadata recollection as publish time.\n                elif creator_id == plate_creator_id:\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update(\n                        {\n                            \"parent_instance_id\": parenting_data[\n                                \"instance_id\"],\n                            \"label\": (\n                                f\"{sub_instance_data['folderPath']} \"\n                                f\"{sub_instance_data['productName']}\"\n                            ),\n                        }\n                    )\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes.update(\n                            {\n                                \"review\": True,\n                                \"reviewableSource\": sub_instance_data[\n                                    \"reviewableSource\"\n                                ],\n                            }\n                        )\n\n                # Audio\n                # insert parent instance data\n                elif creator_id == audio_creator_id:\n                    sub_instance_data[\"variant\"] = \"main\"\n                    sub_instance_data[\"productType\"] = \"audio\"\n                    sub_instance_data[\"productBaseType\"] = \"audio\"\n                    sub_instance_data[\"productName\"] = \"audioMain\"\n\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update(\n                        {\n                            \"parent_instance_id\": parenting_data[\n                                \"instance_id\"],\n                            \"label\": (\n                                f\"{sub_instance_data['folderPath']} \"\n                                f\"{sub_instance_data['productName']}\"\n                            )\n                        }\n                    )\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes[\"review\"] = True\n\n                instance = creator.create(sub_instance_data, None)\n                instance.transient_data[\"segment_item\"] = segment\n\n                instance_data_to_store = instance.data_to_store()\n                shot_instances[creator_id] = instance_data_to_store\n                clip_instances[creator_id] = instance_data_to_store\n\n            pipeline.imprint(\n                segment,\n                data={\n                    _CONTENT_ID: clip_instances,\n                    \"clip_index\": clip_index,\n                }\n            )\n            instances.append(instance)\n\n        self.shot_instances = {}\n        ayfapi.PublishableClip.restore_all_caches()\n\n        return instances\n\n    def _create_and_add_instance(\n            self, data, creator_id, segment, instances):\n        \"\"\"\n        Args:\n            data (dict): The data to re-recreate the instance from.\n            creator_id (str): The creator id to use.\n            segment (obj): The associated segment item.\n            instances (list): Result instance container.\n\n        Returns:\n            CreatedInstance: The newly created instance.\n        \"\"\"\n        creator = self.create_context.creators[creator_id]\n        instance = creator.create(data, None)\n        instance.transient_data[\"segment_item\"] = segment\n        instances.append(instance)\n        return instance\n\n    def _collect_legacy_instance(self, segment, marker_data):\n        \"\"\" Create some instances from legacy marker data.\n\n        Args:\n            segment (object): The segment associated to the marker.\n            marker_data (dict): The marker data.\n\n        Returns:\n            list. All of the created legacy instances.\n        \"\"\"\n        instance_data = marker_data\n        instance_data[\"task\"] = None\n\n        clip_index = str(uuid.uuid4())\n        instance_data[\"clip_index\"] = clip_index\n        clip_instances = {}\n\n        # Create parent shot instance.\n        sub_instance_data = instance_data.copy()\n        segment_data = lib.get_segment_attributes(segment)\n        segment_duration = int(segment_data[\"record_duration\"])\n        workfileFrameStart = sub_instance_data[\"workfileFrameStart\"]\n        sub_instance_data.update({\n            \"creator_attributes\": {\n                \"workfileFrameStart\": workfileFrameStart,\n                \"handleStart\": sub_instance_data[\"handleStart\"],\n                \"handleEnd\": sub_instance_data[\"handleEnd\"],\n                \"frameStart\": workfileFrameStart,\n                \"frameEnd\": (\n                    workfileFrameStart + segment_duration),\n                \"clipIn\": int(segment_data[\"record_in\"]),\n                \"clipOut\": int(segment_data[\"record_out\"]),\n                \"clipDuration\": segment_duration,\n                \"sourceIn\": int(segment_data[\"source_in\"]),\n                \"sourceOut\": int(segment_data[\"source_out\"]),\n                \"includeHandles\": sub_instance_data[\"includeHandles\"],\n                \"retimedHandles\": sub_instance_data[\"retimedHandles\"],\n                \"retimedFramerange\": sub_instance_data[\"retimedFramerange\"],\n                \"useSourceResolution\": sub_instance_data[\"sourceResolution\"],\n            },\n            \"label\": (\n                f\"{sub_instance_data['folderPath']} shot\"\n            ),\n        })\n\n        shot_creator_id = \"io.ayon.creators.flame.shot\"\n        creator = self.create_context.creators[shot_creator_id]\n        instance = creator.create(sub_instance_data, None)\n        instance.transient_data[\"segment_item\"] = segment\n        clip_instances[shot_creator_id] = instance.data_to_store()\n        parenting_data = instance\n\n        # Create plate/audio instance\n        sub_creators = [\"io.ayon.creators.flame.plate\"]\n        if instance_data[\"audio\"]:\n            sub_creators.append(\n                \"io.ayon.creators.flame.audio\"\n            )\n\n        for sub_creator_id in sub_creators:\n            sub_instance_data = deepcopy(instance_data)\n            creator = self.create_context.creators[sub_creator_id]\n            sub_instance_data.update({\n                \"parent_instance_id\": parenting_data[\"instance_id\"],\n                \"label\": (\n                    f\"{sub_instance_data['folderPath']} \"\n                    f\"{creator.product_type}\"\n                ),\n                \"creator_attributes\": {\n                    \"parentInstance\": parenting_data[\"label\"],\n                }\n            })\n\n            # add reviewable source to plate if shot has it\n            if sub_instance_data.get(\"reviewableSource\") != \"&lt; none &gt;\":\n                sub_instance_data[\"creator_attributes\"].update({\n                    \"reviewableSource\": sub_instance_data[\n                        \"reviewTrack\"],\n                    \"review\": True,\n                })\n\n            instance = creator.create(sub_instance_data, None)\n            instance.transient_data[\"segment_item\"] = segment\n            clip_instances[sub_creator_id] = instance.data_to_store()\n\n        # Adjust clip tag to match new publisher\n        pipeline.imprint(\n            segment,\n            data={\n                _CONTENT_ID: clip_instances,\n                \"clip_index\": clip_index,\n            }\n        )\n        return clip_instances.values()\n\n    def collect_instances(self):\n        \"\"\"Collect all created instances from current timeline.\"\"\"\n        # get selection only of sequence clip segments\n        create_settings = self.project_settings[\n            \"flame\"][\"create\"][\"CollectShotClip\"]\n        restrict_to_selection = create_settings[\n            \"collectSelectedInstance\"]\n\n        current_sequence = lib.get_current_sequence(lib.CTX.selection)\n        # only get selected segments if user selected any\n        # and settings are enabled\n        segments = lib.get_sequence_segments(\n            current_sequence, selected=restrict_to_selection\n        )\n\n        if not segments:\n            # get all segments if user didn't select any\n            segments = lib.get_sequence_segments(current_sequence)\n\n        for segment in segments:\n            instances = []\n\n            # attempt to get AYON tag data\n            marker_data = lib.get_segment_data_marker(segment)\n            if not marker_data:\n                continue\n\n            # Legacy instances handling\n            if _CONTENT_ID not in marker_data:\n                instances.extend(\n                    self._collect_legacy_instance(segment, marker_data)\n                )\n                continue\n\n            for creator_id, data in marker_data[_CONTENT_ID].items():\n                self._create_and_add_instance(\n                    data, creator_id, segment, instances)\n\n        return instances\n\n    def update_instances(self, update_list):\n        \"\"\"Never called, update is handled via _FlameInstanceCreator.\"\"\"\n        pass\n\n    def remove_instances(self, instances):\n        \"\"\"Never called, update is handled via _FlameInstanceCreator.\"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.CreateShotClip.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect all created instances from current timeline.</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect all created instances from current timeline.\"\"\"\n    # get selection only of sequence clip segments\n    create_settings = self.project_settings[\n        \"flame\"][\"create\"][\"CollectShotClip\"]\n    restrict_to_selection = create_settings[\n        \"collectSelectedInstance\"]\n\n    current_sequence = lib.get_current_sequence(lib.CTX.selection)\n    # only get selected segments if user selected any\n    # and settings are enabled\n    segments = lib.get_sequence_segments(\n        current_sequence, selected=restrict_to_selection\n    )\n\n    if not segments:\n        # get all segments if user didn't select any\n        segments = lib.get_sequence_segments(current_sequence)\n\n    for segment in segments:\n        instances = []\n\n        # attempt to get AYON tag data\n        marker_data = lib.get_segment_data_marker(segment)\n        if not marker_data:\n            continue\n\n        # Legacy instances handling\n        if _CONTENT_ID not in marker_data:\n            instances.extend(\n                self._collect_legacy_instance(segment, marker_data)\n            )\n            continue\n\n        for creator_id, data in marker_data[_CONTENT_ID].items():\n            self._create_and_add_instance(\n                data, creator_id, segment, instances)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.CreateShotClip.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Never called, update is handled via _FlameInstanceCreator.</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Never called, update is handled via _FlameInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.CreateShotClip.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Never called, update is handled via _FlameInstanceCreator.</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Never called, update is handled via _FlameInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.EditorialAudioInstanceCreator","title":"<code>EditorialAudioInstanceCreator</code>","text":"<p>               Bases: <code>_FlameInstanceClipCreatorBase</code></p> <p>Audio product type creator class</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialAudioInstanceCreator(_FlameInstanceClipCreatorBase):\n    \"\"\"Audio product type creator class\"\"\"\n    identifier = \"io.ayon.creators.flame.audio\"\n    product_type = \"audio\"\n    product_base_type = \"audio\"\n    label = \"Editorial Audio\"\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.EditorialPlateInstanceCreator","title":"<code>EditorialPlateInstanceCreator</code>","text":"<p>               Bases: <code>_FlameInstanceClipCreatorBase</code></p> <p>Plate product type creator class</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialPlateInstanceCreator(_FlameInstanceClipCreatorBase):\n    \"\"\"Plate product type creator class\"\"\"\n    identifier = \"io.ayon.creators.flame.plate\"\n    product_type = \"plate\"\n    product_base_type = \"plate\"\n    label = \"Editorial Plate\"\n\n    def create(self, instance_data, _):\n        \"\"\"Return a new CreateInstance for new shot from Resolve.\n\n        Args:\n            instance_data (dict): global data from original instance\n\n        Return:\n            CreatedInstance: The created instance object for the new shot.\n        \"\"\"\n        return super().create(instance_data, None)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.EditorialPlateInstanceCreator.create","title":"<code>create(instance_data, _)</code>","text":"<p>Return a new CreateInstance for new shot from Resolve.</p> <p>Parameters:</p> Name Type Description Default <code>instance_data</code> <code>dict</code> <p>global data from original instance</p> required Return <p>CreatedInstance: The created instance object for the new shot.</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>def create(self, instance_data, _):\n    \"\"\"Return a new CreateInstance for new shot from Resolve.\n\n    Args:\n        instance_data (dict): global data from original instance\n\n    Return:\n        CreatedInstance: The created instance object for the new shot.\n    \"\"\"\n    return super().create(instance_data, None)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.FlameShotInstanceCreator","title":"<code>FlameShotInstanceCreator</code>","text":"<p>               Bases: <code>_FlameInstanceCreator</code></p> <p>Shot product type creator class</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>class FlameShotInstanceCreator(_FlameInstanceCreator):\n    \"\"\"Shot product type creator class\"\"\"\n    identifier = \"io.ayon.creators.flame.shot\"\n    product_type = \"shot\"\n    product_base_type = \"shot\"\n    label = \"Editorial Shot\"\n\n    def get_instance_attr_defs(self):\n        instance_attributes = list(CLIP_ATTR_DEFS)\n        instance_attributes.append(\n            BoolDef(\n                \"useSourceResolution\",\n                label=\"Set shot resolution from plate\",\n                tooltip=\"Is resolution taken from timeline or source?\",\n                default=False,\n            )\n        )\n        return instance_attributes\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_shot_clip.html#client.ayon_flame.plugins.create.create_shot_clip.get_video_track_names","title":"<code>get_video_track_names(sequence)</code>","text":"<p>Get video track names.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>object</code> <p>The sequence object.</p> required <p>Returns:</p> Type Description <p>list. The track names.</p> Source code in <code>client/ayon_flame/plugins/create/create_shot_clip.py</code> <pre><code>def get_video_track_names(sequence):\n    \"\"\" Get video track names.\n\n    Args:\n        sequence (object): The sequence object.\n\n    Returns:\n        list. The track names.\n    \"\"\"\n    track_names = []\n    for ver in sequence.versions:\n        for track in ver.tracks:\n            track_names.append(track.name.get_value())\n\n    return track_names\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_workfile.html#client.ayon_flame.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_flame/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    settings_category = \"flame\"\n\n    identifier = \"io.ayon.creators.flame.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    product_base_type = \"workfile\"\n    icon = \"fa5.file\"\n    default_variant = \"Main\"\n\n    @staticmethod\n    def _get_project_workfile_filepath():\n        \"\"\"\n        Args:\n            project_name (str): The project name.\n\n        Returns:\n            str. The path to the expected Json workfile.\n        \"\"\"\n        project_name = flapi.get_current_project().name\n        return os.path.join(\n            os.environ[\"AYON_WORKDIR\"],\n            f\"{project_name}.workfile\"\n        )\n\n    def _dump_instance_data(self, data):\n        \"\"\" Dump instance data into a side-car json file.\n\n        Args:\n            data (dict): The data to push to the project metadata.\n\n        Returns:\n            bool. Has the metadata been updated.\n        \"\"\"\n        out_path = self._get_project_workfile_filepath()\n        with open(out_path, \"w\", encoding=\"utf-8\") as out_file:\n            json.dump(data, out_file)\n\n    def _load_instance_data(self):\n        \"\"\" Returns the data stored in side-car json file if exists.\n\n        Returns:\n            dict. The workfile metadata data.\n        \"\"\"\n        in_path = self._get_project_workfile_filepath()\n\n        try:\n            with open(in_path) as in_file:\n                return json.load(in_file)\n        except (FileNotFoundError, json.JSONDecodeError):\n            return {}\n\n    def _create_new_instance(self):\n        \"\"\"Create a new workfile instance.\n\n        Returns:\n            dict. The data of the instance to be created.\n        \"\"\"\n        variant = self.default_variant\n\n        project_entity = self.create_context.get_current_project_entity()\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n\n        project_name = project_entity[\"name\"]\n        folder_path = folder_entity[\"path\"]\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        product_name = self.get_product_name(\n            project_name=project_name,\n            project_entity=project_entity,\n            folder_entity=folder_entity,\n            task_entity=task_entity,\n            variant=self.default_variant,\n            host_name=host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": variant,\n        }\n        data.update(\n            self.get_dynamic_data(\n                variant,\n                task_name,\n                folder_entity,\n                project_name,\n                host_name,\n                False,\n            )\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        current_instance = CreatedInstance(\n            self.product_type, product_name, data, self)\n        self._add_instance_to_context(current_instance)\n        return current_instance\n\n    def create(self, options=None):\n        \"\"\"Auto-create an instance by default.\"\"\"\n        instance_data = self._load_instance_data()\n        if instance_data:\n            return\n\n        self.log.info(\"Auto-creating workfile instance...\")\n        self._create_new_instance()\n\n    def collect_instances(self):\n        \"\"\"Collect from timeline marker or create a new one.\"\"\"\n        data = self._load_instance_data()\n        if not data:\n            return\n\n        instance = CreatedInstance(\n            self.product_type, data[\"productName\"], data, self\n        )\n        self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Store changes in project metadata so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Gets list of tuples. Each item\n                contain changed instance and its changes.\n        \"\"\"\n        for created_inst, _ in update_list:\n            data = created_inst.data_to_store()\n            self._dump_instance_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_workfile.html#client.ayon_flame.plugins.create.create_workfile.CreateWorkfile.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect from timeline marker or create a new one.</p> Source code in <code>client/ayon_flame/plugins/create/create_workfile.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect from timeline marker or create a new one.\"\"\"\n    data = self._load_instance_data()\n    if not data:\n        return\n\n    instance = CreatedInstance(\n        self.product_type, data[\"productName\"], data, self\n    )\n    self._add_instance_to_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_workfile.html#client.ayon_flame.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create(options=None)</code>","text":"<p>Auto-create an instance by default.</p> Source code in <code>client/ayon_flame/plugins/create/create_workfile.py</code> <pre><code>def create(self, options=None):\n    \"\"\"Auto-create an instance by default.\"\"\"\n    instance_data = self._load_instance_data()\n    if instance_data:\n        return\n\n    self.log.info(\"Auto-creating workfile instance...\")\n    self._create_new_instance()\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/create/create_workfile.html#client.ayon_flame.plugins.create.create_workfile.CreateWorkfile.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Store changes in project metadata so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list</code> <code>List[UpdateData]</code> <p>Gets list of tuples. Each item contain changed instance and its changes.</p> required Source code in <code>client/ayon_flame/plugins/create/create_workfile.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Store changes in project metadata so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Gets list of tuples. Each item\n            contain changed instance and its changes.\n    \"\"\"\n    for created_inst, _ in update_list:\n        data = created_inst.data_to_store()\n        self._dump_instance_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip.html","title":"load_clip","text":""},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip.html#client.ayon_flame.plugins.load.load_clip.LoadClip","title":"<code>LoadClip</code>","text":"<p>               Bases: <code>ClipLoader</code></p> <p>Load a product to timeline as clip</p> <p>Place clip to timeline on its asset origin timings collected during conforming to project</p> Source code in <code>client/ayon_flame/plugins/load/load_clip.py</code> <pre><code>class LoadClip(ayfapi.ClipLoader):\n    \"\"\"Load a product to timeline as clip\n\n    Place clip to timeline on its asset origin timings collected\n    during conforming to project\n    \"\"\"\n\n    product_types = {\"render2d\", \"source\", \"plate\", \"render\", \"review\"}\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load as clip\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # settings\n    reel_group_name = \"AYON_Reels\"\n    reel_name = \"Loaded\"\n    clip_name_template = \"{folder[name]}_{product[name]}&lt;_{output}&gt;\"\n\n    \"\"\" Anatomy keys from version context data and dynamically added:\n        - {layerName} - original layer name token\n        - {layerUID} - original layer UID token\n        - {originalBasename} - original clip name taken from file\n    \"\"\"\n    layer_rename_template = \"{folder[name]}_{product[name]}&lt;_{output}&gt;\"\n    layer_rename_patterns = []\n\n    def load(self, context, name, namespace, options):\n\n        # get flame objects\n        fproject = flame.project.current_project\n        self.fpd = fproject.current_workspace.desktop\n\n        # load clip to timeline and get main variables\n        version_entity = context[\"version\"]\n        version_attributes = version_entity[\"attrib\"]\n        version_name = version_entity[\"version\"]\n        colorspace = self.get_colorspace(context)\n\n        # in case output is not in context replace key to representation\n        if not context[\"representation\"][\"context\"].get(\"output\"):\n            self.clip_name_template = self.clip_name_template.replace(\n                \"output\", \"representation\")\n            self.layer_rename_template = self.layer_rename_template.replace(\n                \"output\", \"representation\")\n\n        formatting_data = deepcopy(context[\"representation\"][\"context\"])\n        clip_name = StringTemplate(self.clip_name_template).format(\n            formatting_data)\n\n        # convert colorspace with ocio to flame mapping\n        # in imageio flame section\n        colorspace = self.get_native_colorspace(colorspace)\n        self.log.info(\"Loading with colorspace: `{}`\".format(colorspace))\n\n        # create workfile path\n        workfile_dir = os.environ[\"AYON_WORKDIR\"]\n        openclip_dir = os.path.join(\n            workfile_dir, clip_name\n        )\n        openclip_path = os.path.join(\n            openclip_dir, clip_name + \".clip\"\n        )\n        if not os.path.exists(openclip_dir):\n            os.makedirs(openclip_dir)\n\n        # prepare clip data from context ad send it to openClipLoader\n        path = self.filepath_from_context(context)\n        loading_context = {\n            \"path\": path.replace(\"\\\\\", \"/\"),\n            \"colorspace\": colorspace,\n            \"version\": \"v{:0&gt;3}\".format(version_name),\n            \"layer_rename_template\": self.layer_rename_template,\n            \"layer_rename_patterns\": self.layer_rename_patterns,\n            \"context_data\": formatting_data\n        }\n        self.log.debug(pformat(\n            loading_context\n        ))\n        self.log.debug(openclip_path)\n\n        # make AYON clip file\n        ayfapi.OpenClipSolver(\n            openclip_path, loading_context, logger=self.log).make()\n\n        # prepare Reel group in actual desktop\n        opc = self._get_clip(\n            clip_name,\n            openclip_path\n        )\n\n        # add additional metadata from the version to imprint basic\n        # folder attributes\n        add_keys = [\n            \"frameStart\", \"frameEnd\", \"source\", \"author\",\n            \"fps\", \"handleStart\", \"handleEnd\"\n        ]\n\n        # move all version data keys to tag data\n        data_imprint = {\n            key: version_attributes.get(key, str(None))\n            for key in add_keys\n        }\n\n        # add variables related to version context\n        data_imprint.update({\n            \"version\": version_name,\n            \"colorspace\": colorspace,\n            \"objectName\": clip_name\n        })\n\n        # TODO: finish the containerisation\n        # opc_segment = ayfapi.get_clip_segment(opc)\n\n        # return ayfapi.containerise(\n        #     opc_segment,\n        #     name, namespace, context,\n        #     self.__class__.__name__,\n        #     data_imprint)\n\n        return opc\n\n    def _get_clip(self, name, clip_path):\n        reel = self._get_reel()\n        # with maintained openclip as opc\n        matching_clip = [cl for cl in reel.clips\n                         if cl.name.get_value() == name]\n        if matching_clip:\n            return matching_clip.pop()\n        else:\n            created_clips = flame.import_clips(str(clip_path), reel)\n            return created_clips.pop()\n\n    def _get_reel(self):\n\n        matching_rgroup = [\n            rg for rg in self.fpd.reel_groups\n            if rg.name.get_value() == self.reel_group_name\n        ]\n\n        if not matching_rgroup:\n            reel_group = self.fpd.create_reel_group(str(self.reel_group_name))\n            for _r in reel_group.reels:\n                if \"reel\" not in _r.name.get_value().lower():\n                    continue\n                self.log.debug(\"Removing: {}\".format(_r.name))\n                flame.delete(_r)\n        else:\n            reel_group = matching_rgroup.pop()\n\n        matching_reel = [\n            re for re in reel_group.reels\n            if re.name.get_value() == self.reel_name\n        ]\n\n        if not matching_reel:\n            reel_group = reel_group.create_reel(str(self.reel_name))\n        else:\n            reel_group = matching_reel.pop()\n\n        return reel_group\n\n    def _get_segment_from_clip(self, clip):\n        # unwrapping segment from input clip\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip.html#client.ayon_flame.plugins.load.load_clip.LoadClip.clip_name_template","title":"<code>clip_name_template = '{folder[name]}_{product[name]}&lt;_{output}&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Anatomy keys from version context data and dynamically added: - {layerName} - original layer name token - {layerUID} - original layer UID token - {originalBasename} - original clip name taken from file</p>"},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip_batch.html","title":"load_clip_batch","text":""},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip_batch.html#client.ayon_flame.plugins.load.load_clip_batch.LoadClipBatch","title":"<code>LoadClipBatch</code>","text":"<p>               Bases: <code>ClipLoader</code></p> <p>Load a product to timeline as clip</p> <p>Place clip to timeline on its asset origin timings collected during conforming to project</p> Source code in <code>client/ayon_flame/plugins/load/load_clip_batch.py</code> <pre><code>class LoadClipBatch(ayfapi.ClipLoader):\n    \"\"\"Load a product to timeline as clip\n\n    Place clip to timeline on its asset origin timings collected\n    during conforming to project\n    \"\"\"\n\n    product_types = {\"render2d\", \"source\", \"plate\", \"render\", \"review\"}\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load as clip to current batch\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # settings\n    reel_name = \"AYON_LoadedReel\"\n    clip_name_template = \"{batch}_{folder[name]}_{product[name]}&lt;_{output}&gt;\"\n\n    \"\"\" Anatomy keys from version context data and dynamically added:\n        - {layerName} - original layer name token\n        - {layerUID} - original layer UID token\n        - {originalBasename} - original clip name taken from file\n    \"\"\"\n    layer_rename_template = \"{folder[name]}_{product[name]}&lt;_{output}&gt;\"\n    layer_rename_patterns = []\n\n    def load(self, context, name, namespace, options):\n\n        # get flame objects\n        self.batch = options.get(\"batch\") or flame.batch\n\n        # load clip to timeline and get main variables\n        version_entity = context[\"version\"]\n        version_attributes =version_entity[\"attrib\"]\n        version_name = version_entity[\"version\"]\n        colorspace = self.get_colorspace(context)\n\n        clip_name_template = self.clip_name_template\n        layer_rename_template = self.layer_rename_template\n        # in case output is not in context replace key to representation\n        if not context[\"representation\"][\"context\"].get(\"output\"):\n            clip_name_template = clip_name_template.replace(\n                \"output\", \"representation\")\n            layer_rename_template = layer_rename_template.replace(\n                \"output\", \"representation\")\n\n        folder_entity = context[\"folder\"]\n        product_entity = context[\"product\"]\n        formatting_data = deepcopy(context[\"representation\"][\"context\"])\n        formatting_data[\"batch\"] = self.batch.name.get_value()\n        formatting_data.update({\n            \"asset\": folder_entity[\"name\"],\n            \"folder\": {\n                \"name\": folder_entity[\"name\"],\n            },\n            \"subset\": product_entity[\"name\"],\n            \"family\": product_entity[\"productType\"],\n            \"product\": {\n                \"name\": product_entity[\"name\"],\n                \"type\": product_entity[\"productType\"],\n            }\n        })\n\n        clip_name = StringTemplate(clip_name_template).format(\n            formatting_data)\n\n        # convert colorspace with ocio to flame mapping\n        # in imageio flame section\n        colorspace = self.get_native_colorspace(colorspace)\n        self.log.info(\"Loading with colorspace: `{}`\".format(colorspace))\n\n        # create workfile path\n        workfile_dir = options.get(\"workdir\") or os.environ[\"AYON_WORKDIR\"]\n        openclip_dir = os.path.join(\n            workfile_dir, clip_name\n        )\n        openclip_path = os.path.join(\n            openclip_dir, clip_name + \".clip\"\n        )\n\n        if not os.path.exists(openclip_dir):\n            os.makedirs(openclip_dir)\n\n        # prepare clip data from context and send it to openClipLoader\n        path = self.filepath_from_context(context)\n        loading_context = {\n            \"path\": path.replace(\"\\\\\", \"/\"),\n            \"colorspace\": colorspace,\n            \"version\": \"v{:0&gt;3}\".format(version_name),\n            \"layer_rename_template\": layer_rename_template,\n            \"layer_rename_patterns\": self.layer_rename_patterns,\n            \"context_data\": formatting_data\n        }\n        self.log.debug(pformat(\n            loading_context\n        ))\n        self.log.debug(openclip_path)\n\n        # make AYON clip file\n        ayfapi.OpenClipSolver(\n            openclip_path, loading_context, logger=self.log).make()\n\n        # prepare Reel group in actual desktop\n        opc = self._get_clip(\n            clip_name,\n            openclip_path\n        )\n\n        # add additional metadata from the version to imprint basic\n        # folder attributes\n        add_keys = [\n            \"frameStart\", \"frameEnd\", \"source\", \"author\",\n            \"fps\", \"handleStart\", \"handleEnd\"\n        ]\n\n        # move all version data keys to tag data\n        data_imprint = {\n            key: version_attributes.get(key, str(None))\n            for key in add_keys\n        }\n        # add variables related to version context\n        data_imprint.update({\n            \"version\": version_name,\n            \"colorspace\": colorspace,\n            \"objectName\": clip_name\n        })\n\n        # TODO: finish the containerisation\n        # opc_segment = ayfapi.get_clip_segment(opc)\n\n        # return ayfapi.containerise(\n        #     opc_segment,\n        #     name, namespace, context,\n        #     self.__class__.__name__,\n        #     data_imprint)\n\n        return opc\n\n    def _get_clip(self, name, clip_path):\n        reel = self._get_reel()\n\n        # with maintained openclip as opc\n        matching_clip = None\n        for cl in reel.clips:\n            if cl.name.get_value() != name:\n                continue\n            matching_clip = cl\n\n        if not matching_clip:\n            created_clips = flame.import_clips(str(clip_path), reel)\n            return created_clips.pop()\n\n        return matching_clip\n\n    def _get_reel(self):\n\n        matching_reel = [\n            rg for rg in self.batch.reels\n            if rg.name.get_value() == self.reel_name\n        ]\n\n        return (\n            matching_reel.pop()\n            if matching_reel\n            else self.batch.create_reel(str(self.reel_name))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/load/load_clip_batch.html#client.ayon_flame.plugins.load.load_clip_batch.LoadClipBatch.clip_name_template","title":"<code>clip_name_template = '{batch}_{folder[name]}_{product[name]}&lt;_{output}&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Anatomy keys from version context data and dynamically added: - {layerName} - original layer name token - {layerUID} - original layer UID token - {originalBasename} - original clip name taken from file</p>"},{"location":"autoapi/client/ayon_flame/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_audio.html#client.ayon_flame.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new audio.</p> Source code in <code>client/ayon_flame/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.InstancePlugin):\n    \"\"\"Collect new audio.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Audio\"\n    hosts = [\"flame\"]\n    families = [\"audio\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise RuntimeError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        if instance.data.get(\"reviewTrack\") is not None:\n            instance.data[\"reviewAudio\"] = True\n            # Remove review track to avoid creation of reviewable\n            #     for the instance\n            instance.data.pop(\"reviewTrack\")\n\n        clip_src = instance.data[\"otioClip\"].source_range\n        clip_src_in = clip_src.start_time.to_frames()\n        clip_src_out = clip_src_in + clip_src.duration.to_frames()\n        instance.data.update({\n            \"clipInH\": clip_src_in,\n            \"clipOutH\": clip_src_out\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_audio.html#client.ayon_flame.plugins.publish.collect_audio.CollectAudio.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_flame/plugins/publish/collect_audio.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n    edit_shared_data = instance.context.data[\"editorialSharedData\"]\n    instance.data.update(\n        edit_shared_data[parent_instance_id]\n    )\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise RuntimeError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    if instance.data.get(\"reviewTrack\") is not None:\n        instance.data[\"reviewAudio\"] = True\n        # Remove review track to avoid creation of reviewable\n        #     for the instance\n        instance.data.pop(\"reviewTrack\")\n\n    clip_src = instance.data[\"otioClip\"].source_range\n    clip_src_in = clip_src.start_time.to_frames()\n    clip_src_out = clip_src_in + clip_src.duration.to_frames()\n    instance.data.update({\n        \"clipInH\": clip_src_in,\n        \"clipOutH\": clip_src_out\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_plate.html","title":"collect_plate","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_plate.html#client.ayon_flame.plugins.publish.collect_plate.CollectPlate","title":"<code>CollectPlate</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new plates.</p> Source code in <code>client/ayon_flame/plugins/publish/collect_plate.py</code> <pre><code>class CollectPlate(pyblish.api.InstancePlugin):\n    \"\"\"Collect new plates.\"\"\"\n\n    order = order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Plate\"\n    hosts = [\"flame\"]\n    families = [\"plate\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"families\"].append(\"clip\")\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise RuntimeError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        # solve reviewable options\n        review_switch = instance.data[\"creator_attributes\"].get(\n            \"review\")\n        reviewable_source = instance.data[\"creator_attributes\"].get(\n            \"reviewableSource\")\n\n        if review_switch is True:\n            if reviewable_source == \"clip_media\":\n                instance.data[\"families\"].append(\"review\")\n                instance.data.pop(\"reviewTrack\", None)\n            else:\n                instance.data[\"reviewTrack\"] = reviewable_source\n\n        # remove creator-specific review keys from instance data\n        instance.data.pop(\"reviewableSource\", None)\n        instance.data.pop(\"review\", None)\n\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n        segment_item = instance.data[\"item\"]\n        sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n        with ayfapi.maintained_segment_selection(sequence):\n            clip_data = ayfapi.get_segment_attributes(segment_item)\n\n        version_data = instance.data.setdefault(\"versionData\", {})\n        version_data[\"colorSpace\"] = clip_data[\"colour_space\"]\n        instance.data[\"colorspace\"] = clip_data[\"colour_space\"]\n\n        instance.data[\"shotDurationFromSource\"] = instance.data.get(\n            \"retimedFramerange\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_plate.html#client.ayon_flame.plugins.publish.collect_plate.CollectPlate.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_flame/plugins/publish/collect_plate.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"families\"].append(\"clip\")\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise RuntimeError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    # solve reviewable options\n    review_switch = instance.data[\"creator_attributes\"].get(\n        \"review\")\n    reviewable_source = instance.data[\"creator_attributes\"].get(\n        \"reviewableSource\")\n\n    if review_switch is True:\n        if reviewable_source == \"clip_media\":\n            instance.data[\"families\"].append(\"review\")\n            instance.data.pop(\"reviewTrack\", None)\n        else:\n            instance.data[\"reviewTrack\"] = reviewable_source\n\n    # remove creator-specific review keys from instance data\n    instance.data.pop(\"reviewableSource\", None)\n    instance.data.pop(\"review\", None)\n\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n    edit_shared_data = instance.context.data[\"editorialSharedData\"]\n\n    instance.data.update(\n        edit_shared_data[parent_instance_id]\n    )\n\n    segment_item = instance.data[\"item\"]\n    sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n    with ayfapi.maintained_segment_selection(sequence):\n        clip_data = ayfapi.get_segment_attributes(segment_item)\n\n    version_data = instance.data.setdefault(\"versionData\", {})\n    version_data[\"colorSpace\"] = clip_data[\"colour_space\"]\n    instance.data[\"colorspace\"] = clip_data[\"colour_space\"]\n\n    instance.data[\"shotDurationFromSource\"] = instance.data.get(\n        \"retimedFramerange\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_shots.html","title":"collect_shots","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_shots.html#client.ayon_flame.plugins.publish.collect_shots.CollectShot","title":"<code>CollectShot</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new shots.</p> Source code in <code>client/ayon_flame/plugins/publish/collect_shots.py</code> <pre><code>class CollectShot(pyblish.api.InstancePlugin):\n    \"\"\"Collect new shots.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Collect Shots\"\n    hosts = [\"flame\"]\n    families = [\"shot\"]\n\n    SHARED_KEYS = (\n        \"folderPath\",\n        \"fps\",\n        \"handleStart\",\n        \"handleEnd\",\n        \"item\",\n        \"resolutionWidth\",\n        \"resolutionHeight\",\n        \"retimedHandles\",\n        \"retimedFramerange\",\n        \"path\",\n        \"pixelAspect\",\n        \"sourceFirstFrame\",\n        \"versionData\",\n        \"workfileFrameStart\",\n        \"xml_overrides\",\n        \"failing\",\n    )\n\n    # TODO: add to own plugin for Flame\n    # TODO: toggle for marking task which should be used for product parent\n    add_tasks = []\n\n    @classmethod\n    def _inject_editorial_shared_data(cls, instance):\n        \"\"\"\n        Args:\n            instance (obj): The publishing instance.\n        \"\"\"\n        context = instance.context\n        instance_id = instance.data[\"instance_id\"]\n\n        # Inject folderPath and other creator_attributes to ensure\n        # new shots/hierarchy are properly handled.\n        creator_attributes = instance.data['creator_attributes']\n        instance.data.update(creator_attributes)\n\n        # Inject/Distribute instance shot data as editorialSharedData\n        # to make it available for clip/plate/audio products\n        # in sub-collectors.\n        if not context.data.get(\"editorialSharedData\"):\n            context.data[\"editorialSharedData\"] = {}\n\n        context.data[\"editorialSharedData\"][instance_id] = {\n            key: value for key, value in instance.data.items()\n            if key in cls.SHARED_KEYS\n        }\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"integrate\"] = False  # no representation for shot\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, _ = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise RuntimeError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        # Compute fps from creator attribute.\n        creator_attrs = instance.data['creator_attributes']\n        if creator_attrs[\"fps\"] == \"from_selection\":\n            creator_attrs[\"fps\"] = instance.context.data[\"fps\"]\n\n        # Retrieve AyonData marker for associated clip.\n        instance.data[\"otioClip\"] = otio_clip\n\n        # Compute additional data\n        segment_item = None\n        for item in instance.context.data[\"flameSegments\"]:\n            item_data = ayfapi.get_segment_data_marker(item) or {}\n            if item_data.get(\"clip_index\") == instance.data[\"clip_index\"]:\n                segment_item = item\n                break\n\n        if segment_item is None:\n            raise PublishError(\n                \"Could not retrieve source from sequence segments.\")\n\n        comment_attributes = self._get_comment_attributes(segment_item)\n        instance.data.update(comment_attributes)\n\n        sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n        with ayfapi.maintained_segment_selection(sequence):\n            validation_aggregator = ayfapi.ValidationAggregator()\n            clip_data = ayfapi.get_segment_attributes(\n                segment_item, validation_aggregator=validation_aggregator)\n            clip_name = clip_data[\"segment_name\"]\n            self.log.debug(f\"clip_name: {clip_name}\")\n\n        # get file path\n        file_path = None\n        first_frame = 0\n        head = 0\n        tail = 0\n        if not validation_aggregator.has_errors():\n            file_path = clip_data[\"fpath\"]\n            first_frame = ayfapi.get_frame_from_filename(file_path) or 0\n\n            # get file path\n            head, tail = self._get_head_tail(\n                clip_data,\n                otio_clip,\n                creator_attrs[\"handleStart\"],\n                creator_attrs[\"handleEnd\"]\n            )\n\n        # Make sure there is not None and negative number\n        head = abs(head or 0)\n        tail = abs(tail or 0)\n\n        # solve handles length\n        creator_attrs[\"handleStart\"] = min(\n            creator_attrs[\"handleStart\"], head)\n        creator_attrs[\"handleEnd\"] = min(\n            creator_attrs[\"handleEnd\"], tail)\n\n        # Adjust info from track_item on timeline\n        workfile_start = self._set_workfile_start(creator_attrs)\n\n        instance.data.update({\n            \"item\": segment_item,\n            \"path\": file_path,\n            \"failing\": validation_aggregator.has_errors(),\n            \"sourceFirstFrame\": int(first_frame),\n            \"workfileFrameStart\": workfile_start,\n            \"flameAddTasks\": self.add_tasks,\n            \"tasks\": {\n                task[\"name\"]: {\"type\": task[\"type\"]}\n                for task in self.add_tasks\n            },\n        })\n\n        self._get_resolution_to_data(instance.data, instance.context)\n        self._inject_editorial_shared_data(instance)\n        self.log.debug(f\"__ inst_data: {pformat(instance.data)}\")\n\n    @staticmethod\n    def _set_workfile_start(data):\n        include_handles = data.get(\"includeHandles\")\n        workfile_start = data[\"workfileFrameStart\"]\n        handle_start = data[\"handleStart\"]\n\n        if include_handles:\n            workfile_start += handle_start\n\n        return workfile_start\n\n    def _get_comment_attributes(self, segment):\n        comment = segment.comment.get_value()\n\n        # try to find attributes\n        attributes = {\n            \"xml_overrides\": {\n                \"pixelRatio\": 1.00}\n        }\n        # search for `:`\n        for split in self._split_comments(comment):\n            # make sure we ignore if not `:` in key\n            if \":\" not in split:\n                continue\n\n            self._get_xml_preset_attrs(\n                attributes, split)\n\n        # add xml overrides resolution to instance data\n        xml_overrides = attributes[\"xml_overrides\"]\n        if xml_overrides.get(\"width\"):\n            attributes.update({\n                \"resolutionWidth\": xml_overrides[\"width\"],\n                \"resolutionHeight\": xml_overrides[\"height\"],\n                \"pixelAspect\": xml_overrides[\"pixelRatio\"]\n            })\n\n        return attributes\n\n    def _get_xml_preset_attrs(self, attributes, split):\n\n        # split to key and value\n        key, value = split.split(\":\", 1)\n\n        for attr_data in self.xml_preset_attrs_from_comments:\n            a_name = attr_data[\"name\"]\n            a_type = attr_data[\"type\"]\n\n            # exclude all not related attributes\n            if a_name.lower() not in key.lower():\n                continue\n\n            # get pattern defined by type\n            pattern = TXT_PATTERN\n            if a_type in (\"number\", \"float\"):\n                pattern = NUM_PATTERN\n\n            res_goup = pattern.findall(value)\n\n            # raise if nothing is found as it is not correctly defined\n            if not res_goup:\n                raise ValueError((\n                    \"Value for `{}` attribute is not \"\n                    \"set correctly: `{}`\").format(a_name, split))\n\n            if \"string\" in a_type:\n                _value = res_goup[0]\n            if \"float\" in a_type:\n                _value = float(res_goup[0])\n            if \"number\" in a_type:\n                _value = int(res_goup[0])\n\n            attributes[\"xml_overrides\"][a_name] = _value\n\n        # condition for resolution in key\n        if \"resolution\" in key.lower():\n            res_goup = NUM_PATTERN.findall(value)\n            # check if axpect was also defined\n            # 1920x1080x1.5\n            aspect = res_goup[2] if len(res_goup) &gt; 2 else 1\n\n            width = int(res_goup[0])\n            height = int(res_goup[1])\n            pixel_ratio = float(aspect)\n            attributes[\"xml_overrides\"].update({\n                \"width\": width,\n                \"height\": height,\n                \"pixelRatio\": pixel_ratio\n            })\n\n    def _split_comments(self, comment_string):\n        # first split comment by comma\n        pattern = \"|\".join([\",\", \";\"])\n        return re.split(pattern, comment_string)\n\n    def _get_resolution_to_data(self, data, context):\n        assert data.get(\"otioClip\"), \"Missing `otioClip` data\"\n\n        # solve source resolution option\n        if data[\"creator_attributes\"].get(\"useSourceResolution\", None):\n            otio_clip_metadata = data[\n                \"otioClip\"].media_reference.metadata\n            data.update({\n                \"resolutionWidth\": otio_clip_metadata[\n                        \"ayon.source.width\"],\n                \"resolutionHeight\": otio_clip_metadata[\n                    \"ayon.source.height\"],\n                \"pixelAspect\": otio_clip_metadata[\n                    \"ayon.source.pixelAspect\"]\n            })\n        else:\n            otio_tl_metadata = context.data[\"otioTimeline\"].metadata\n            data.update({\n                \"resolutionWidth\": otio_tl_metadata[\"ayon.timeline.width\"],\n                \"resolutionHeight\": otio_tl_metadata[\n                    \"ayon.timeline.height\"],\n                \"pixelAspect\": otio_tl_metadata[\n                    \"ayon.timeline.pixelAspect\"]\n            })\n\n    def _get_head_tail(self, clip_data, otio_clip, handle_start, handle_end):\n        # calculate head and tail with forward compatibility\n        head = clip_data.get(\"segment_head\")\n        tail = clip_data.get(\"segment_tail\")\n        self.log.debug(f\"__ head: `{head}`\")\n        self.log.debug(f\"__ tail: `{tail}`\")\n\n        # HACK: it is here to serve for versions below 2021.1\n        if not any([head, tail]):\n            retimed_attributes = get_media_range_with_retimes(\n                otio_clip, handle_start, handle_end)\n            self.log.debug(f\"&gt;&gt; retimed_attributes: {retimed_attributes}\")\n\n            # retimed head and tail\n            head = int(retimed_attributes[\"handleStart\"])\n            tail = int(retimed_attributes[\"handleEnd\"])\n\n        return head, tail\n\n    def _create_otio_time_range_from_timeline_item_data(self, clip_data):\n        frame_start = int(clip_data[\"record_in\"])\n        frame_duration = int(clip_data[\"record_duration\"])\n\n        return flame_export.create_otio_time_range(\n            frame_start, frame_duration, self.fps)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_shots.html#client.ayon_flame.plugins.publish.collect_shots.CollectShot.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_flame/plugins/publish/collect_shots.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"integrate\"] = False  # no representation for shot\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, _ = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise RuntimeError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    # Compute fps from creator attribute.\n    creator_attrs = instance.data['creator_attributes']\n    if creator_attrs[\"fps\"] == \"from_selection\":\n        creator_attrs[\"fps\"] = instance.context.data[\"fps\"]\n\n    # Retrieve AyonData marker for associated clip.\n    instance.data[\"otioClip\"] = otio_clip\n\n    # Compute additional data\n    segment_item = None\n    for item in instance.context.data[\"flameSegments\"]:\n        item_data = ayfapi.get_segment_data_marker(item) or {}\n        if item_data.get(\"clip_index\") == instance.data[\"clip_index\"]:\n            segment_item = item\n            break\n\n    if segment_item is None:\n        raise PublishError(\n            \"Could not retrieve source from sequence segments.\")\n\n    comment_attributes = self._get_comment_attributes(segment_item)\n    instance.data.update(comment_attributes)\n\n    sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n    with ayfapi.maintained_segment_selection(sequence):\n        validation_aggregator = ayfapi.ValidationAggregator()\n        clip_data = ayfapi.get_segment_attributes(\n            segment_item, validation_aggregator=validation_aggregator)\n        clip_name = clip_data[\"segment_name\"]\n        self.log.debug(f\"clip_name: {clip_name}\")\n\n    # get file path\n    file_path = None\n    first_frame = 0\n    head = 0\n    tail = 0\n    if not validation_aggregator.has_errors():\n        file_path = clip_data[\"fpath\"]\n        first_frame = ayfapi.get_frame_from_filename(file_path) or 0\n\n        # get file path\n        head, tail = self._get_head_tail(\n            clip_data,\n            otio_clip,\n            creator_attrs[\"handleStart\"],\n            creator_attrs[\"handleEnd\"]\n        )\n\n    # Make sure there is not None and negative number\n    head = abs(head or 0)\n    tail = abs(tail or 0)\n\n    # solve handles length\n    creator_attrs[\"handleStart\"] = min(\n        creator_attrs[\"handleStart\"], head)\n    creator_attrs[\"handleEnd\"] = min(\n        creator_attrs[\"handleEnd\"], tail)\n\n    # Adjust info from track_item on timeline\n    workfile_start = self._set_workfile_start(creator_attrs)\n\n    instance.data.update({\n        \"item\": segment_item,\n        \"path\": file_path,\n        \"failing\": validation_aggregator.has_errors(),\n        \"sourceFirstFrame\": int(first_frame),\n        \"workfileFrameStart\": workfile_start,\n        \"flameAddTasks\": self.add_tasks,\n        \"tasks\": {\n            task[\"name\"]: {\"type\": task[\"type\"]}\n            for task in self.add_tasks\n        },\n    })\n\n    self._get_resolution_to_data(instance.data, instance.context)\n    self._inject_editorial_shared_data(instance)\n    self.log.debug(f\"__ inst_data: {pformat(instance.data)}\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_test_selection.html","title":"collect_test_selection","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_test_selection.html#client.ayon_flame.plugins.publish.collect_test_selection.CollectTestSelection","title":"<code>CollectTestSelection</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>testing selection sharing</p> Source code in <code>client/ayon_flame/plugins/publish/collect_test_selection.py</code> <pre><code>class CollectTestSelection(pyblish.api.ContextPlugin):\n    \"\"\"testing selection sharing\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"test selection\"\n    hosts = [\"flame\"]\n    active = False\n\n    def process(self, context):\n        self.log.info(\n            \"Active Selection: {}\".format(ayfapi.CTX.selection))\n\n        sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n\n        self.test_print_attributes(sequence)\n        self.test_otio_export(sequence)\n\n    def test_otio_export(self, sequence):\n        test_dir = os.path.normpath(\n            tempfile.mkdtemp(prefix=\"test_pyblish_tmp_\")\n        )\n        export_path = os.path.normpath(\n            os.path.join(\n                test_dir, \"otio_timeline_export.otio\"\n            )\n        )\n        self.log.debug(export_path)\n        validation_aggregator = ayfapi.ValidationAggregator()\n        otio_timeline = otio_export.create_otio_timeline(\n            sequence, validation_aggregator=validation_aggregator)\n\n        failed_segments = validation_aggregator.failed_segments\n        self.log.info(failed_segments)\n        for segment in failed_segments:\n            self.log.error(f\"Failed segment: {segment.name}\")\n\n        otio_export.write_to_file(\n            otio_timeline, export_path\n        )\n        read_timeline_otio = otio.adapters.read_from_file(export_path)\n\n        # Making sure timelines are the same and exporting did not\n        # change anything\n        if len(str(otio_timeline)) != len(str(read_timeline_otio)):\n            raise Exception(\"Exported timeline is different from original\")\n\n        self.log.info(pformat(otio_timeline))\n        self.log.info(\"Otio exported to: {}\".format(export_path))\n\n    def test_print_attributes(self, sequence):\n        with ayfapi.maintained_segment_selection(sequence) as sel_segments:\n            for segment in sel_segments:\n                self.log.debug(\"Segment with AYONData: {}\".format(\n                    segment.name))\n\n                self.print_segment_properties(segment)\n\n    def print_segment_properties(self, segment):\n        \"\"\"Loop through a PySegment object's attributes and print properties.\n\n        Args:\n            segment: A flame.PySegment object\n        \"\"\"\n        # Get all attributes\n        attributes = dir(segment)\n\n        self.log.debug(\"Properties of the PySegment object:\")\n        self.log.debug(\"-\" * 40)\n        for attr in attributes:\n            if (\n                not attr.startswith(\"__\")\n                and not callable(getattr(segment, attr))\n            ):\n                self.log.debug(f\"{attr}: {getattr(segment, attr)}\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_test_selection.html#client.ayon_flame.plugins.publish.collect_test_selection.CollectTestSelection.print_segment_properties","title":"<code>print_segment_properties(segment)</code>","text":"<p>Loop through a PySegment object's attributes and print properties.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <p>A flame.PySegment object</p> required Source code in <code>client/ayon_flame/plugins/publish/collect_test_selection.py</code> <pre><code>def print_segment_properties(self, segment):\n    \"\"\"Loop through a PySegment object's attributes and print properties.\n\n    Args:\n        segment: A flame.PySegment object\n    \"\"\"\n    # Get all attributes\n    attributes = dir(segment)\n\n    self.log.debug(\"Properties of the PySegment object:\")\n    self.log.debug(\"-\" * 40)\n    for attr in attributes:\n        if (\n            not attr.startswith(\"__\")\n            and not callable(getattr(segment, attr))\n        ):\n            self.log.debug(f\"{attr}: {getattr(segment, attr)}\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_timeline_otio.html","title":"collect_timeline_otio","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/collect_timeline_otio.html#client.ayon_flame.plugins.publish.collect_timeline_otio.CollecTimelineOTIO","title":"<code>CollecTimelineOTIO</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working context into publish context</p> Source code in <code>client/ayon_flame/plugins/publish/collect_timeline_otio.py</code> <pre><code>class CollecTimelineOTIO(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working context into publish context\"\"\"\n\n    label = \"Collect Timeline OTIO\"\n    order = pyblish.api.CollectorOrder - 0.491\n\n    def process(self, context):\n\n        # main\n        project = ayfapi.get_current_project()\n        sequence = ayfapi.get_current_sequence(ayfapi.CTX.selection)\n        segments = ayfapi.get_sequence_segments(sequence)\n\n        # adding otio timeline to context\n        validation_aggregator = ayfapi.ValidationAggregator()\n        with ayfapi.maintained_segment_selection(sequence):\n            otio_timeline = flame_export.create_otio_timeline(\n                sequence, validation_aggregator=validation_aggregator)\n\n        failed_segments = validation_aggregator.failed_segments\n\n        # update context with main project attributes\n        timeline_data = {\n            \"flameProject\": project,\n            \"flameSequence\": sequence,\n            \"failedSegments\": failed_segments,\n            \"otioTimeline\": otio_timeline,\n            \"currentFile\": \"Flame/{}/{}\".format(\n                project.name, sequence.name.get_value()\n            ),\n            \"flameSegments\": segments,\n            \"fps\": float(str(sequence.frame_rate)[:-4])\n        }\n        self.log.debug(f\"&gt;&gt;&gt; Timeline data: {pformat(timeline_data)}\")\n        context.data.update(timeline_data)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_otio_file.html","title":"extract_otio_file","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_otio_file.html#client.ayon_flame.plugins.publish.extract_otio_file.ExtractOTIOFile","title":"<code>ExtractOTIOFile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor export OTIO file</p> Source code in <code>client/ayon_flame/plugins/publish/extract_otio_file.py</code> <pre><code>class ExtractOTIOFile(publish.Extractor):\n    \"\"\"\n    Extractor export OTIO file\n    \"\"\"\n\n    label = \"Extract OTIO file\"\n    order = pyblish.api.ExtractorOrder - 0.45\n    families = [\"workfile\"]\n    hosts = [\"flame\"]\n\n    def process(self, instance):\n        # create representation data\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        name = instance.data[\"name\"]\n        staging_dir = self.staging_dir(instance)\n\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        # create otio timeline representation\n        otio_file_name = name + \".otio\"\n        otio_file_path = os.path.join(staging_dir, otio_file_name)\n\n        # export otio file to temp dir\n        otio.adapters.write_to_file(otio_timeline, otio_file_path)\n\n        representation_otio = {\n            'name': \"otio\",\n            'ext': \"otio\",\n            'files': otio_file_name,\n            \"stagingDir\": staging_dir,\n        }\n\n        instance.data[\"representations\"].append(representation_otio)\n\n        self.log.info(\"Added OTIO file representation: {}\".format(\n            representation_otio))\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_product_resources.html","title":"extract_product_resources","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_product_resources.html#client.ayon_flame.plugins.publish.extract_product_resources.ExtractProductResources","title":"<code>ExtractProductResources</code>","text":"<p>               Bases: <code>Extractor</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Extractor for transcoding files from Flame clip</p> Source code in <code>client/ayon_flame/plugins/publish/extract_product_resources.py</code> <pre><code>class ExtractProductResources(\n    publish.Extractor,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"\n    Extractor for transcoding files from Flame clip\n    \"\"\"\n\n    label = \"Extract product resources\"\n    order = pyblish.api.ExtractorOrder\n    families = [\"clip\"]\n    hosts = [\"flame\"]\n\n    settings_category = \"flame\"\n\n    # plugin defaults\n    keep_original_representation = False\n\n    default_presets = {\n        \"thumbnail\": {\n            \"active\": True,\n            \"ext\": \"jpg\",\n            \"xml_preset_file\": \"Jpeg (8-bit).xml\",\n            \"xml_preset_dir\": \"\",\n            \"export_type\": \"File Sequence\",\n            \"parsed_comment_attrs\": False,\n            \"colorspace_out\": \"Output - sRGB\",\n            \"representation_add_range\": False,\n            \"representation_tags\": [\"thumbnail\"],\n            \"path_regex\": \".*\"\n        }\n    }\n\n    # hide publisher during exporting\n    hide_ui_on_process = True\n\n    # settings\n    export_presets_mapping = []\n\n    def process(self, instance):\n        if not self.keep_original_representation:\n            # remove previeous representation if not needed\n            instance.data[\"representations\"] = []\n\n        # flame objects\n        segment = instance.data[\"item\"]\n        folder_path = instance.data[\"folderPath\"]\n        segment_name = segment.name.get_value()\n        clip_path = instance.data[\"path\"]\n        sequence_clip = instance.context.data[\"flameSequence\"]\n\n        # segment's parent track name\n        s_track_name = segment.parent.name.get_value()\n\n        # get configured workfile frame start/end (handles excluded)\n        frame_start = instance.data[\"frameStart\"]\n        # get media source first frame\n        source_first_frame = instance.data[\"sourceFirstFrame\"]\n\n        self.log.debug(\"_ frame_start: {}\".format(frame_start))\n        self.log.debug(\"_ source_first_frame: {}\".format(source_first_frame))\n\n        # get timeline in/out of segment\n        clip_in = instance.data[\"clipIn\"]\n        clip_out = instance.data[\"clipOut\"]\n\n        # get retimed attributres\n        retimed_data = self._get_retimed_attributes(instance)\n\n        # get individual keys\n        retimed_handle_start = retimed_data[\"handle_start\"]\n        retimed_handle_end = retimed_data[\"handle_end\"]\n        retimed_source_duration = retimed_data[\"source_duration\"]\n        retimed_speed = retimed_data[\"speed\"]\n\n        # get handles value - take only the max from both\n        handle_start = instance.data[\"handleStart\"]\n        handle_end = instance.data[\"handleEnd\"]\n        handles = max(handle_start, handle_end)\n        include_handles = instance.data.get(\"includeHandles\")\n        retimed_handles = instance.data.get(\"retimedHandles\")\n\n        # get media source range with handles\n        source_start_handles = instance.data[\"sourceStartH\"]\n        source_end_handles = instance.data[\"sourceEndH\"]\n\n        # retime if needed\n        if retimed_speed != 1.0:\n            if retimed_handles:\n                # handles are retimed\n                source_start_handles = (\n                    instance.data[\"sourceStart\"] - retimed_handle_start)\n                source_end_handles = (\n                    source_start_handles\n                    + (retimed_source_duration - 1)\n                    + retimed_handle_start\n                    + retimed_handle_end\n                )\n\n            else:\n                # handles are not retimed\n                source_end_handles = (\n                    source_start_handles\n                    + (retimed_source_duration - 1)\n                    + handle_start\n                    + handle_end\n                )\n\n        # get frame range with handles for representation range\n        frame_start_handle = frame_start - handle_start\n        repre_frame_start = frame_start_handle\n        if include_handles:\n            if retimed_speed == 1.0 or not retimed_handles:\n                frame_start_handle = frame_start\n            else:\n                frame_start_handle = (\n                    frame_start - handle_start) + retimed_handle_start\n\n        self.log.debug(\"_ frame_start_handle: {}\".format(\n            frame_start_handle))\n        self.log.debug(\"_ repre_frame_start: {}\".format(\n            repre_frame_start))\n\n        # calculate duration with handles\n        source_duration_handles = (\n            source_end_handles - source_start_handles) + 1\n\n        self.log.debug(\"_ source_duration_handles: {}\".format(\n            source_duration_handles))\n\n        # create staging dir path\n        staging_dir = self.staging_dir(instance)\n\n        # append staging dir for later cleanup\n        instance.context.data[\"cleanupFullPaths\"].append(staging_dir)\n\n        export_presets_mapping = {}\n        for preset_mapping in deepcopy(self.export_presets_mapping):\n            name = preset_mapping.pop(\"name\")\n            export_presets_mapping[name] = preset_mapping\n\n        # add default preset type for thumbnail and reviewable video\n        # update them with settings and override in case the same\n        # are found in there\n        _preset_keys = [k.split('_')[0] for k in export_presets_mapping]\n        export_presets = {\n            k: v\n            for k, v in deepcopy(self.default_presets).items()\n            if k not in _preset_keys\n        }\n        export_presets.update(export_presets_mapping)\n\n        if not instance.data.get(\"versionData\"):\n            instance.data[\"versionData\"] = {}\n\n        # set versiondata if any retime\n        version_data = retimed_data.get(\"version_data\")\n        self.log.debug(\"_ version_data: {}\".format(version_data))\n\n        if version_data:\n            instance.data[\"versionData\"].update(version_data)\n\n        # version data start frame\n        version_frame_start = frame_start\n        if include_handles:\n            version_frame_start = frame_start_handle\n        if retimed_speed != 1.0:\n            if retimed_handles:\n                instance.data[\"versionData\"].update({\n                    \"frameStart\": version_frame_start,\n                    \"frameEnd\": (\n                        (version_frame_start + source_duration_handles - 1)\n                        - (retimed_handle_start + retimed_handle_end)\n                    )\n                })\n            else:\n                instance.data[\"versionData\"].update({\n                    \"handleStart\": handle_start,\n                    \"handleEnd\": handle_end,\n                    \"frameStart\": version_frame_start,\n                    \"frameEnd\": (\n                        (version_frame_start + source_duration_handles - 1)\n                        - (handle_start + handle_end)\n                    )\n                })\n        self.log.debug(\"_ version_data: {}\".format(\n            instance.data[\"versionData\"]\n        ))\n\n        # loop all preset names and\n        for unique_name, preset_config in export_presets.items():\n            modify_xml_data = {}\n\n            if self._should_skip(preset_config, clip_path, unique_name):\n                continue\n\n            # get all presets attributes\n            extension = preset_config[\"ext\"]\n            preset_file = preset_config[\"xml_preset_file\"]\n            preset_dir = preset_config[\"xml_preset_dir\"]\n            export_type = preset_config[\"export_type\"]\n            repre_tags = preset_config[\"representation_tags\"]\n            parsed_comment_attrs = preset_config[\"parsed_comment_attrs\"]\n\n            self.log.info(\n                \"Processing `{}` as `{}` to `{}` type...\".format(\n                    preset_file, export_type, extension\n                )\n            )\n\n            exporting_clip = None\n            name_pattern_xml = \"&lt;name&gt;_{}.\".format(\n                unique_name)\n\n            if export_type == \"Sequence Publish\":\n                # change export clip to sequence\n                exporting_clip = flame.duplicate(sequence_clip)\n\n                # only keep visible layer where instance segment is child\n                self.hide_others(\n                    exporting_clip, segment_name, s_track_name)\n\n                # change name pattern\n                name_pattern_xml = (\n                    \"&lt;segment name&gt;_&lt;shot name&gt;_{}.\").format(\n                        unique_name)\n\n                # only for h264 with baked retime\n                in_mark = clip_in\n                out_mark = clip_out + 1\n                modify_xml_data.update({\n                    \"exportHandles\": True,\n                    \"nbHandles\": handles\n                })\n            else:\n                in_mark = (source_start_handles - source_first_frame) + 1\n                out_mark = in_mark + source_duration_handles\n                exporting_clip = self.import_clip(clip_path)\n                exporting_clip.name.set_value(\"{}_{}\".format(\n                    folder_path, segment_name))\n\n            flame_colour = exporting_clip.get_colour_space()\n            self.log.debug(flame_colour)\n            context = instance.context\n            host_name = context.data[\"hostName\"]\n            project_settings = context.data[\"project_settings\"]\n            host_imageio_settings = project_settings[\"flame\"][\"imageio\"]\n            imageio_colorspace = get_remapped_colorspace_from_native(\n                flame_colour,\n                host_name,\n                host_imageio_settings,\n            )\n            self.log.debug(imageio_colorspace)\n            # add xml tags modifications\n            modify_xml_data.update({\n                # enum position low start from 0\n                \"frameIndex\": 0,\n                \"startFrame\": repre_frame_start,\n                \"namePattern\": name_pattern_xml\n            })\n\n            if parsed_comment_attrs:\n                # add any xml overrides collected form segment.comment\n                modify_xml_data.update(instance.data[\"xml_overrides\"])\n\n            self.log.debug(\"_ in_mark: {}\".format(in_mark))\n            self.log.debug(\"_ out_mark: {}\".format(out_mark))\n\n            export_kwargs = {}\n            # validate xml preset file is filled\n            if preset_file == \"\":\n                raise ValueError(\n                    (\"Check Settings for {} preset: \"\n                        \"`XML preset file` is not filled\").format(\n                        unique_name)\n                )\n\n            # resolve xml preset dir if not filled\n            if preset_dir == \"\":\n                preset_dir = ayfapi.get_preset_path_by_xml_name(\n                    preset_file)\n\n                if not preset_dir:\n                    raise ValueError(\n                        (\"Check Settings for {} preset: \"\n                            \"`XML preset file` {} is not found\").format(\n                            unique_name, preset_file)\n                    )\n\n            # create preset path\n            preset_orig_xml_path = str(os.path.join(\n                preset_dir, preset_file\n            ))\n\n            # define kwargs based on preset type\n            if \"thumbnail\" in unique_name:\n                modify_xml_data.update({\n                    \"video/posterFrame\": True,\n                    \"video/useFrameAsPoster\": 1,\n                    \"namePattern\": \"__thumbnail\"\n                })\n                thumb_frame_number = int(in_mark + (\n                    (out_mark - in_mark + 1) / 2))\n\n                self.log.debug(\"__ thumb_frame_number: {}\".format(\n                    thumb_frame_number\n                ))\n\n                export_kwargs[\"thumb_frame_number\"] = thumb_frame_number\n            else:\n                export_kwargs.update({\n                    \"in_mark\": in_mark,\n                    \"out_mark\": out_mark\n                })\n\n            preset_path = ayfapi.modify_preset_file(\n                preset_orig_xml_path, staging_dir, modify_xml_data)\n\n            # get and make export dir paths\n            export_dir_path = str(os.path.join(\n                staging_dir, unique_name\n            ))\n            os.makedirs(export_dir_path)\n\n            # export\n            ayfapi.export_clip(\n                export_dir_path, exporting_clip, preset_path, **export_kwargs)\n\n            repr_name = unique_name\n            # make sure only first segment is used if underscore in name\n            # HACK: `ftrackreview_withLUT` will result only in `ftrackreview`\n            if (\n                \"thumbnail\" in unique_name\n                or \"ftrackreview\" in unique_name\n            ):\n                repr_name = unique_name.split(\"_\")[0]\n\n            # create representation data\n            representation_data = {\n                \"name\": repr_name,\n                \"outputName\": repr_name,\n                \"ext\": extension,\n                \"stagingDir\": export_dir_path,\n                \"tags\": repre_tags,\n                \"load_to_batch_group\": preset_config.get(\n                    \"load_to_batch_group\"),\n                \"batch_group_loader_name\": preset_config.get(\n                    \"batch_group_loader_name\") or None\n            }\n\n            # collect all available content of export dir\n            files = os.listdir(export_dir_path)\n\n            # make sure no nested folders inside\n            n_stage_dir, n_files = self._unfolds_nested_folders(\n                export_dir_path, files, extension)\n\n            # fix representation in case of nested folders\n            if n_stage_dir:\n                representation_data[\"stagingDir\"] = n_stage_dir\n                files = n_files\n\n            # add files to representation but add\n            # imagesequence as list\n            if (\n                # first check if path in files is not mov extension\n                [\n                    f for f in files\n                    if os.path.splitext(f)[-1] == \".mov\"\n                ]\n                # then try if thumbnail is not in unique name\n                or repr_name == \"thumbnail\"\n            ):\n                representation_data[\"files\"] = files.pop()\n            else:\n                representation_data[\"files\"] = files\n\n            # add frame range\n            if preset_config[\"representation_add_range\"]:\n                representation_data.update({\n                    \"frameStart\": repre_frame_start,\n                    \"frameEnd\": (\n                        repre_frame_start + source_duration_handles) - 1,\n                    \"fps\": instance.data[\"fps\"]\n                })\n\n            self.set_representation_colorspace(\n                representation_data,\n                instance.context,\n                colorspace=imageio_colorspace,\n            )\n\n            instance.data[\"representations\"].append(representation_data)\n\n            # add review family if found in tags\n            if \"review\" in repre_tags:\n                instance.data[\"families\"].append(\"review\")\n\n            self.log.info(\"Added representation: {}\".format(\n                representation_data))\n\n            if export_type == \"Sequence Publish\":\n                publish_clips = flame.find_by_name(\n                    f\"{exporting_clip.name.get_value()}_publish\",\n                    parent=exporting_clip.parent\n                )\n                for publish_clip in publish_clips:\n                    flame.delete(publish_clip)\n                # at the end remove the duplicated clip\n                flame.delete(exporting_clip)\n\n    def _get_retimed_attributes(self, instance):\n        handle_start = instance.data[\"handleStart\"]\n        handle_end = instance.data[\"handleEnd\"]\n\n        # get basic variables\n        otio_clip = instance.data[\"otioClip\"]\n\n        # get available range trimmed with processed retimes\n        retimed_attributes = get_media_range_with_retimes(\n            otio_clip, handle_start, handle_end)\n        self.log.debug(\n            \"&gt;&gt; retimed_attributes: {}\".format(retimed_attributes))\n\n        r_media_in = int(retimed_attributes[\"mediaIn\"])\n        r_media_out = int(retimed_attributes[\"mediaOut\"])\n        version_data = retimed_attributes.get(\"versionData\")\n\n        return {\n            \"version_data\": version_data,\n            \"handle_start\": int(retimed_attributes[\"handleStart\"]),\n            \"handle_end\": int(retimed_attributes[\"handleEnd\"]),\n            \"source_duration\": (\n                (r_media_out - r_media_in) + 1\n            ),\n            \"speed\": float(retimed_attributes[\"speed\"])\n        }\n\n    def _should_skip(self, preset_config, clip_path, unique_name):\n        # get activating attributes\n        activated_preset = preset_config[\"active\"]\n        filter_path_regex = preset_config.get(\"filter_path_regex\")\n\n        self.log.info(\n            \"Preset `{}` is active `{}` with filter `{}`\".format(\n                unique_name, activated_preset, filter_path_regex\n            )\n        )\n\n        # skip if not activated presets\n        if not activated_preset:\n            return True\n\n        # exclude by regex filter if any\n        if (\n            filter_path_regex\n            and not re.search(filter_path_regex, clip_path)\n        ):\n            return True\n\n    def _unfolds_nested_folders(self, stage_dir, files_list, ext):\n        \"\"\"Unfolds nested folders\n\n        Args:\n            stage_dir (str): path string with directory\n            files_list (list): list of file names\n            ext (str): extension (jpg)[without dot]\n\n        Raises:\n            IOError: in case no files were collected form any directory\n\n        Returns:\n            str, list: new staging dir path, new list of file names\n            or\n            None, None: In case single file in `files_list`\n        \"\"\"\n        # exclude single files which are having extension\n        # the same as input ext attr\n        if (\n            # only one file in list\n            len(files_list) == 1\n            # file is having extension as input\n            and ext in os.path.splitext(files_list[0])[-1]\n        ):\n            return None, None\n        elif (\n            # more then one file in list\n            len(files_list) &gt;= 1\n            # extension is correct\n            and ext in os.path.splitext(files_list[0])[-1]\n            # test file exists\n            and os.path.exists(\n                os.path.join(stage_dir, files_list[0])\n            )\n        ):\n            return None, None\n\n        new_stage_dir = None\n        new_files_list = []\n        for file in files_list:\n            search_path = os.path.join(stage_dir, file)\n            if not os.path.isdir(search_path):\n                continue\n            for root, _dirs, files in os.walk(search_path):\n                for _file in files:\n                    _fn, _ext = os.path.splitext(_file)\n                    if ext.lower() != _ext[1:].lower():\n                        continue\n                    new_files_list.append(_file)\n                    if not new_stage_dir:\n                        new_stage_dir = root\n\n        if not new_stage_dir:\n            raise AssertionError(\n                \"Files in `{}` are not correct! Check `{}`\".format(\n                    files_list, stage_dir)\n            )\n\n        return new_stage_dir, new_files_list\n\n    def hide_others(self, sequence_clip, segment_name, track_name):\n        \"\"\"Helper method used only if sequence clip is used\n\n        Args:\n            sequence_clip (flame.Clip): sequence clip\n            segment_name (str): segment name\n            track_name (str): track name\n        \"\"\"\n        # create otio tracks and clips\n        for ver in sequence_clip.versions:\n            for track in ver.tracks:\n                if len(track.segments) == 0 and track.hidden.get_value():\n                    continue\n\n                # hide tracks which are not parent track\n                if track.name.get_value() != track_name:\n                    track.hidden = True\n                    continue\n\n                # hidde all other segments\n                for segment in track.segments:\n                    if segment.name.get_value() != segment_name:\n                        segment.hidden = True\n\n    def import_clip(self, path):\n        \"\"\"\n        Import clip from path\n        \"\"\"\n        dir_path = os.path.dirname(path)\n        media_info = MediaInfoFile(path, logger=self.log)\n        file_pattern = media_info.file_pattern\n        self.log.debug(\"__ file_pattern: {}\".format(file_pattern))\n\n        # rejoin the pattern to dir path\n        new_path = os.path.join(dir_path, file_pattern)\n\n        clips = flame.import_clips(new_path)\n        self.log.info(\"Clips [{}] imported from `{}`\".format(clips, path))\n\n        if not clips:\n            self.log.warning(\"Path `{}` is not having any clips\".format(path))\n            return None\n        elif len(clips) &gt; 1:\n            self.log.warning(\n                \"Path `{}` is containing more that one clip\".format(path)\n            )\n        return clips[0]\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_product_resources.html#client.ayon_flame.plugins.publish.extract_product_resources.ExtractProductResources.hide_others","title":"<code>hide_others(sequence_clip, segment_name, track_name)</code>","text":"<p>Helper method used only if sequence clip is used</p> <p>Parameters:</p> Name Type Description Default <code>sequence_clip</code> <code>Clip</code> <p>sequence clip</p> required <code>segment_name</code> <code>str</code> <p>segment name</p> required <code>track_name</code> <code>str</code> <p>track name</p> required Source code in <code>client/ayon_flame/plugins/publish/extract_product_resources.py</code> <pre><code>def hide_others(self, sequence_clip, segment_name, track_name):\n    \"\"\"Helper method used only if sequence clip is used\n\n    Args:\n        sequence_clip (flame.Clip): sequence clip\n        segment_name (str): segment name\n        track_name (str): track name\n    \"\"\"\n    # create otio tracks and clips\n    for ver in sequence_clip.versions:\n        for track in ver.tracks:\n            if len(track.segments) == 0 and track.hidden.get_value():\n                continue\n\n            # hide tracks which are not parent track\n            if track.name.get_value() != track_name:\n                track.hidden = True\n                continue\n\n            # hidde all other segments\n            for segment in track.segments:\n                if segment.name.get_value() != segment_name:\n                    segment.hidden = True\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/extract_product_resources.html#client.ayon_flame.plugins.publish.extract_product_resources.ExtractProductResources.import_clip","title":"<code>import_clip(path)</code>","text":"<p>Import clip from path</p> Source code in <code>client/ayon_flame/plugins/publish/extract_product_resources.py</code> <pre><code>def import_clip(self, path):\n    \"\"\"\n    Import clip from path\n    \"\"\"\n    dir_path = os.path.dirname(path)\n    media_info = MediaInfoFile(path, logger=self.log)\n    file_pattern = media_info.file_pattern\n    self.log.debug(\"__ file_pattern: {}\".format(file_pattern))\n\n    # rejoin the pattern to dir path\n    new_path = os.path.join(dir_path, file_pattern)\n\n    clips = flame.import_clips(new_path)\n    self.log.info(\"Clips [{}] imported from `{}`\".format(clips, path))\n\n    if not clips:\n        self.log.warning(\"Path `{}` is not having any clips\".format(path))\n        return None\n    elif len(clips) &gt; 1:\n        self.log.warning(\n            \"Path `{}` is containing more that one clip\".format(path)\n        )\n    return clips[0]\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/integrate_batch_group.html","title":"integrate_batch_group","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/integrate_batch_group.html#client.ayon_flame.plugins.publish.integrate_batch_group.IntegrateBatchGroup","title":"<code>IntegrateBatchGroup</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Integrate published shot to batch group</p> Source code in <code>client/ayon_flame/plugins/publish/integrate_batch_group.py</code> <pre><code>class IntegrateBatchGroup(pyblish.api.InstancePlugin):\n    \"\"\"Integrate published shot to batch group\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.45\n    label = \"Integrate Batch Groups\"\n    hosts = [\"flame\"]\n    families = [\"clip\"]\n\n    settings_category = \"flame\"\n\n    # settings\n    default_loader = \"LoadClip\"\n\n    def process(self, instance):\n        add_tasks = instance.data[\"flameAddTasks\"]\n\n        # iterate all tasks from settings\n        for task_data in add_tasks:\n            # exclude batch group\n            if not task_data[\"create_batch_group\"]:\n                continue\n\n            # create or get already created batch group\n            bgroup = self._get_batch_group(instance, task_data)\n\n            # add batch group content\n            all_batch_nodes = self._add_nodes_to_batch_with_links(\n                instance, task_data, bgroup)\n\n            for name, node in all_batch_nodes.items():\n                self.log.debug(\"name: {}, dir: {}\".format(\n                    name, dir(node)\n                ))\n                self.log.debug(\"__ node.attributes: {}\".format(\n                    node.attributes\n                ))\n\n            # load plate to batch group\n            self.log.info(\"Loading product `{}` into batch `{}`\".format(\n                instance.data[\"productName\"], bgroup.name.get_value()\n            ))\n            self._load_clip_to_context(instance, bgroup)\n\n    def _add_nodes_to_batch_with_links(self, instance, task_data, batch_group):\n        # get write file node properties &gt; OrederDict because order does matter\n        write_pref_data = self._get_write_prefs(instance, task_data)\n\n        batch_nodes = [\n            {\n                \"type\": \"comp\",\n                \"properties\": {},\n                \"id\": \"comp_node01\"\n            },\n            {\n                \"type\": \"Write File\",\n                \"properties\": write_pref_data,\n                \"id\": \"write_file_node01\"\n            }\n        ]\n        batch_links = [\n            {\n                \"from_node\": {\n                    \"id\": \"comp_node01\",\n                    \"connector\": \"Result\"\n                },\n                \"to_node\": {\n                    \"id\": \"write_file_node01\",\n                    \"connector\": \"Front\"\n                }\n            }\n        ]\n\n        # add nodes into batch group\n        return ayfapi.create_batch_group_conent(\n            batch_nodes, batch_links, batch_group)\n\n    def _load_clip_to_context(self, instance, bgroup):\n        # get all loaders for host\n        loaders_by_name = {\n            loader.__name__: loader\n            for loader in op_pipeline.discover_loader_plugins()\n        }\n\n        # get all published representations\n        published_representations = instance.data[\"published_representations\"]\n        repres_db_id_by_name = {\n            repre_info[\"representation\"][\"name\"]: repre_id\n            for repre_id, repre_info in published_representations.items()\n        }\n\n        # get all loadable representations\n        repres_by_name = {\n            repre[\"name\"]: repre for repre in instance.data[\"representations\"]\n        }\n\n        # get repre_id for the loadable representations\n        loader_name_by_repre_id = {\n            repres_db_id_by_name[repr_name]: {\n                \"loader\": repr_data[\"batch_group_loader_name\"],\n                # add repre data for exception logging\n                \"_repre_data\": repr_data\n            }\n            for repr_name, repr_data in repres_by_name.items()\n            if repr_data.get(\"load_to_batch_group\")\n        }\n\n        self.log.debug(\"__ loader_name_by_repre_id: {}\".format(pformat(\n            loader_name_by_repre_id)))\n\n        # get representation context from the repre_id\n        repre_contexts = op_pipeline.load.get_repres_contexts(\n            loader_name_by_repre_id.keys())\n\n        self.log.debug(\"__ repre_contexts: {}\".format(pformat(\n            repre_contexts)))\n\n        # loop all returned repres from repre_context dict\n        for repre_id, repre_context in repre_contexts.items():\n            self.log.debug(\"__ repre_id: {}\".format(repre_id))\n            # get loader name by representation id\n            loader_name = (\n                loader_name_by_repre_id[repre_id][\"loader\"]\n                # if nothing was added to settings fallback to default\n                or self.default_loader\n            )\n\n            # get loader plugin\n            loader_plugin = loaders_by_name.get(loader_name)\n            if loader_plugin:\n                # load to flame by representation context\n                try:\n                    op_pipeline.load.load_with_repre_context(\n                        loader_plugin, repre_context, **{\n                            \"data\": {\n                                \"workdir\": self.task_workdir,\n                                \"batch\": bgroup\n                            }\n                        })\n                except op_pipeline.load.IncompatibleLoaderError as msg:\n                    self.log.error(\n                        \"Check allowed representations for Loader `{}` \"\n                        \"in settings &gt; error: {}\".format(\n                            loader_plugin.__name__, msg))\n                    self.log.error(\n                        \"Representaton context &gt;&gt;{}&lt;&lt; is not compatible \"\n                        \"with loader `{}`\".format(\n                            pformat(repre_context), loader_plugin.__name__\n                        )\n                    )\n            else:\n                self.log.warning(\n                    \"Something got wrong and there is not Loader found for \"\n                    \"following data: {}\".format(\n                        pformat(loader_name_by_repre_id))\n                )\n\n    def _get_batch_group(self, instance, task_data):\n        frame_start = instance.data[\"frameStart\"]\n        frame_end = instance.data[\"frameEnd\"]\n        handle_start = instance.data[\"handleStart\"]\n        handle_end = instance.data[\"handleEnd\"]\n        frame_duration = (frame_end - frame_start) + 1\n        folder_path = instance.data[\"folderPath\"]\n\n        task_name = task_data[\"name\"]\n        batchgroup_name = \"{}_{}\".format(folder_path, task_name)\n\n        batch_data = {\n            \"shematic_reels\": [\n                \"AYON_LoadedReel\"\n            ],\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end\n        }\n        self.log.debug(\n            \"__ batch_data: {}\".format(pformat(batch_data)))\n\n        # check if the batch group already exists\n        bgroup = ayfapi.get_batch_group_from_desktop(batchgroup_name)\n\n        if not bgroup:\n            self.log.info(\n                \"Creating new batch group: {}\".format(batchgroup_name))\n            # create batch with utils\n            bgroup = ayfapi.create_batch_group(\n                batchgroup_name,\n                frame_start,\n                frame_duration,\n                **batch_data\n            )\n\n        else:\n            self.log.info(\n                \"Updating batch group: {}\".format(batchgroup_name))\n            # update already created batch group\n            bgroup = ayfapi.create_batch_group(\n                batchgroup_name,\n                frame_start,\n                frame_duration,\n                update_batch_group=bgroup,\n                **batch_data\n            )\n\n        return bgroup\n\n    def _get_anamoty_data_with_current_task(self, instance, task_data):\n        anatomy_data = copy.deepcopy(instance.data[\"anatomyData\"])\n        task_name = task_data[\"name\"]\n        task_type = task_data[\"type\"]\n        anatomy_obj = instance.context.data[\"anatomy\"]\n\n        # update task data in anatomy data\n        project_task_types = anatomy_obj[\"tasks\"]\n        task_code = project_task_types.get(task_type, {}).get(\"shortName\")\n        anatomy_data.update({\n            \"task\": {\n                \"name\": task_name,\n                \"type\": task_type,\n                \"short\": task_code\n            }\n        })\n        return anatomy_data\n\n    def _get_write_prefs(self, instance, task_data):\n        # update task in anatomy data\n        anatomy_data = self._get_anamoty_data_with_current_task(\n            instance, task_data)\n\n        self.task_workdir = self._get_shot_task_dir_path(\n            instance, task_data)\n        self.log.debug(\"__ task_workdir: {}\".format(\n            self.task_workdir))\n\n        # TODO: this might be done with template in settings\n        render_dir_path = os.path.join(\n            self.task_workdir, \"render\", \"flame\")\n\n        if not os.path.exists(render_dir_path):\n            os.makedirs(render_dir_path, mode=0o777)\n\n        # TODO: add most of these to `imageio/flame/batch/write_node`\n        name = \"{project[code]}_{folder[name]}_{task[name]}\".format(\n            **anatomy_data\n        )\n\n        # The path attribute where the rendered clip is exported\n        # /path/to/file.[0001-0010].exr\n        media_path = render_dir_path\n        # name of file represented by tokens\n        media_path_pattern = (\n            \"&lt;name&gt;_v&lt;iteration###&gt;/&lt;name&gt;_v&lt;iteration###&gt;.&lt;frame&gt;&lt;ext&gt;\")\n        # The Create Open Clip attribute of the Write File node. \\\n        # Determines if an Open Clip is created by the Write File node.\n        create_clip = True\n        # The Include Setup attribute of the Write File node.\n        # Determines if a Batch Setup file is created by the Write File node.\n        include_setup = True\n        # The path attribute where the Open Clip file is exported by\n        # the Write File node.\n        create_clip_path = \"&lt;name&gt;\"\n        # The path attribute where the Batch setup file\n        # is exported by the Write File node.\n        include_setup_path = \"./&lt;name&gt;_v&lt;iteration###&gt;\"\n        # The file type for the files written by the Write File node.\n        # Setting this attribute also overwrites format_extension,\n        # bit_depth and compress_mode to match the defaults for\n        # this file type.\n        file_type = \"OpenEXR\"\n        # The file extension for the files written by the Write File node.\n        # This attribute resets to match file_type whenever file_type\n        # is set. If you require a specific extension, you must\n        # set format_extension after setting file_type.\n        format_extension = \"exr\"\n        # The bit depth for the files written by the Write File node.\n        # This attribute resets to match file_type whenever file_type is set.\n        bit_depth = \"16\"\n        # The compressing attribute for the files exported by the Write\n        # File node. Only relevant when file_type in 'OpenEXR', 'Sgi', 'Tiff'\n        compress = True\n        # The compression format attribute for the specific File Types\n        # export by the Write File node. You must set compress_mode\n        # after setting file_type.\n        compress_mode = \"DWAB\"\n        # The frame index mode attribute of the Write File node.\n        # Value range: `Use Timecode` or `Use Start Frame`\n        frame_index_mode = \"Use Start Frame\"\n        frame_padding = 6\n        # The versioning mode of the Open Clip exported by the Write File node.\n        # Only available if create_clip = True.\n        version_mode = \"Follow Iteration\"\n        version_name = \"v&lt;version&gt;\"\n        version_padding = 3\n\n        # need to make sure the order of keys is correct\n        return OrderedDict((\n            (\"name\", name),\n            (\"media_path\", media_path),\n            (\"media_path_pattern\", media_path_pattern),\n            (\"create_clip\", create_clip),\n            (\"include_setup\", include_setup),\n            (\"create_clip_path\", create_clip_path),\n            (\"include_setup_path\", include_setup_path),\n            (\"file_type\", file_type),\n            (\"format_extension\", format_extension),\n            (\"bit_depth\", bit_depth),\n            (\"compress\", compress),\n            (\"compress_mode\", compress_mode),\n            (\"frame_index_mode\", frame_index_mode),\n            (\"frame_padding\", frame_padding),\n            (\"version_mode\", version_mode),\n            (\"version_name\", version_name),\n            (\"version_padding\", version_padding)\n        ))\n\n    def _get_shot_task_dir_path(self, instance, task_data):\n        project_entity = instance.data[\"projectEntity\"]\n        folder_entity = instance.data[\"folderEntity\"]\n        task_entity = instance.data[\"taskEntity\"]\n        anatomy = instance.context.data[\"anatomy\"]\n        project_settings = instance.context.data[\"project_settings\"]\n\n        return get_workdir(\n            project_entity,\n            folder_entity,\n            task_entity,\n            \"flame\",\n            anatomy=anatomy,\n            project_settings=project_settings\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/validate_product_attributes.html","title":"validate_product_attributes","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/validate_product_attributes.html#client.ayon_flame.plugins.publish.validate_product_attributes.ValidateProductAttributes","title":"<code>ValidateProductAttributes</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validate Product attributes.</p> Source code in <code>client/ayon_flame/plugins/publish/validate_product_attributes.py</code> <pre><code>class ValidateProductAttributes(\n    OptionalPyblishPluginMixin,\n    pyblish.api.InstancePlugin\n):\n    \"\"\"Validate Product attributes.\"\"\"\n\n    label = \"Validate Product Attributes\"\n    order = pyblish.api.ValidatorOrder\n    settings_category = \"flame\"\n\n    optional = True\n    active = True\n\n    actions = [DeactivatePublishing]\n\n    def detect_failing_instance(self, instance):\n        return instance.data.get(\"failing\")\n\n    def process(self, instance):\n        if not self.detect_failing_instance(instance):\n            return\n\n        segment = instance.data[\"item\"]\n        otio_clip = instance.data[\"otioClip\"]\n        reference_name = otio_clip.media_reference.name\n\n        msg = \"Product is failing validation due following reason:\"\n        msg_html = self.get_description()\n\n        shot_name = segment.shot_name.get_value()\n        segment_name = segment.name.get_value()\n        clip_msg = (\n            f\"Clip name: '{segment_name}' with shot name: '{shot_name}'\\n\"\n            f\"Problem: '{reference_name}'\"\n        )\n        msg += f\"\\n{clip_msg}\"\n\n        msg_html += f\"{clip_msg}\"\n\n        raise PublishValidationError(\n            title=\"Failing Product Validation\",\n            message=msg,\n            description=msg_html\n        )\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ## Product is failing validation:\n            &lt;br/&gt;\n            Make sure your clips on timeline are not converted to BatchFX&lt;br/&gt;\n            or are not Hard Committed. This way they will lose their link &lt;br/&gt;\n            to the original Media source file path and we are not able&lt;br/&gt;\n            to publish them anymore.\n            &lt;br/&gt;&lt;br/&gt;\n            Also make sure timeline clip has a standard name.\n            &lt;br/&gt;&lt;br/&gt;\n            &lt;b&gt;Validation problem:&lt;/b&gt;\n            &lt;br/&gt;\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/plugins/publish/validate_segments.html","title":"validate_segments","text":""},{"location":"autoapi/client/ayon_flame/plugins/publish/validate_segments.html#client.ayon_flame.plugins.publish.validate_segments.ValidateSegments","title":"<code>ValidateSegments</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validate segments attributes.</p> Source code in <code>client/ayon_flame/plugins/publish/validate_segments.py</code> <pre><code>class ValidateSegments(\n    OptionalPyblishPluginMixin,\n    pyblish.api.ContextPlugin\n):\n    \"\"\"Validate segments attributes.\"\"\"\n\n    label = \"Validate Segments\"\n    order = pyblish.api.ValidatorOrder\n    settings_category = \"flame\"\n\n    optional = True\n    active = False\n\n    actions = [ShowSegmentsRed, HideSegments]\n\n    def process(self, context):\n        failed_segments = context.data[\"failedSegments\"]\n\n        if not failed_segments:\n            return\n\n        msg = \"Timeline Clips failing validation:\"\n        msg_html = self.get_description()\n        for segment in failed_segments:\n            shot_name = segment.shot_name.get_value()\n            segment_name = segment.name.get_value()\n            clip_msg = (\n                f\"Clip name: '{segment_name}' with shot name: '{shot_name}'\")\n            msg += f\"\\n{clip_msg}\"\n\n            msg_html += f\"&lt;br/&gt; - {clip_msg}\"\n\n        raise PublishValidationError(\n            title=\"Missing correct segments attributes\",\n            message=msg,\n            description=msg_html\n        )\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ## Following clips are failing validation:\n            &lt;br/&gt;\n            Make sure your clips on timeline are not converted to BatchFX\n            or are not Hard Committed. This way they will lose their link to\n            the original Media source file path and we are not able\n            to publish them anymore.\n            &lt;br/&gt;&lt;br/&gt;\n            &lt;b&gt;Following clips are failing validation:&lt;/b&gt;\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html","title":"AYON_in_flame","text":""},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.app_initialized","title":"<code>app_initialized(parent=None)</code>","text":"<p>Inicialization of Framework</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>obj</code> <p>Parent object. Defaults to None.</p> <code>None</code> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def app_initialized(parent=None):\n    \"\"\"Inicialization of Framework\n\n    Args:\n        parent (obj, optional): Parent object. Defaults to None.\n    \"\"\"\n    flame_api.CTX.app_framework = flame_api.FlameAppFramework()\n\n    print(f\"{flame_api.CTX.app_framework.bundle_name} initializing\")\n\n    load_apps()\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.ayon_flame_install","title":"<code>ayon_flame_install()</code>","text":"<p>Registering AYON in context</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def ayon_flame_install():\n    \"\"\"Registering AYON in context\n    \"\"\"\n    flame_host = FlameHost()\n    install_host(flame_host)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleaning up Flame framework context</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def cleanup():\n    \"\"\"Cleaning up Flame framework context\n    \"\"\"\n    if flame_api.CTX.flame_apps:\n        print(\n            f\"`{__file__}` cleaning up flame_apps:\\n \"\n            f\"{pformat(flame_api.CTX.flame_apps)}\\n\"\n        )\n        while len(flame_api.CTX.flame_apps):\n            app = flame_api.CTX.flame_apps.pop()\n            print(f\"`{__file__}` removing : {app.name}\")\n            del app\n        flame_api.CTX.flame_apps = []\n\n    if flame_api.CTX.app_framework:\n        print(f\"AYON\\t: {flame_api.CTX.app_framework.bundle_name} cleaning up\")\n        flame_api.CTX.app_framework.save_prefs()\n        flame_api.CTX.app_framework = None\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.exception_handler","title":"<code>exception_handler(exctype, value, _traceback)</code>","text":"<p>Exception handler for improving UX</p> <p>Parameters:</p> Name Type Description Default <code>exctype</code> <code>str</code> <p>type of exception</p> required <code>value</code> <code>str</code> <p>exception value</p> required <code>tb</code> <code>str</code> <p>traceback to show</p> required Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def exception_handler(exctype, value, _traceback):\n    \"\"\"Exception handler for improving UX\n\n    Args:\n        exctype (str): type of exception\n        value (str): exception value\n        tb (str): traceback to show\n    \"\"\"\n    msg = f\"AYON: Python exception {value} in {exctype}\"\n    mbox = QtWidgets.QMessageBox()\n    mbox.setText(msg)\n    mbox.setDetailedText(\n        pformat(traceback.format_exception(exctype, value, _traceback)))\n    mbox.setStyleSheet(\"QLabel{min-width: 800px;}\")\n    mbox.exec_()\n    sys.__excepthook__(exctype, value, _traceback)\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.get_batch_custom_ui_actions","title":"<code>get_batch_custom_ui_actions()</code>","text":"<p>Hook to create submenu in batch</p> <p>Returns:</p> Name Type Description <code>list</code> <p>menu object</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def get_batch_custom_ui_actions():\n    \"\"\"Hook to create submenu in batch\n\n    Returns:\n        list: menu object\n    \"\"\"\n    # install AYON and the host\n    ayon_flame_install()\n\n    return _build_app_menu(\"FlameMenuUniversal\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.get_main_menu_custom_ui_actions","title":"<code>get_main_menu_custom_ui_actions()</code>","text":"<p>Hook to create submenu in start menu</p> <p>Returns:</p> Name Type Description <code>list</code> <p>menu object</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def get_main_menu_custom_ui_actions():\n    \"\"\"Hook to create submenu in start menu\n\n    Returns:\n        list: menu object\n    \"\"\"\n    # install AYON and the host\n    ayon_flame_install()\n\n    return _build_app_menu(\"FlameMenuProjectConnect\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.get_media_panel_custom_ui_actions","title":"<code>get_media_panel_custom_ui_actions()</code>","text":"<p>Hook to create submenu in desktop</p> <p>Returns:</p> Name Type Description <code>list</code> <p>menu object</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def get_media_panel_custom_ui_actions():\n    \"\"\"Hook to create submenu in desktop\n\n    Returns:\n        list: menu object\n    \"\"\"\n    # install AYON and the host\n    ayon_flame_install()\n\n    return _build_app_menu(\"FlameMenuUniversal\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.get_timeline_custom_ui_actions","title":"<code>get_timeline_custom_ui_actions()</code>","text":"<p>Hook to create submenu in timeline</p> <p>Returns:</p> Name Type Description <code>list</code> <p>menu object</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def get_timeline_custom_ui_actions():\n    \"\"\"Hook to create submenu in timeline\n\n    Returns:\n        list: menu object\n    \"\"\"\n    # install AYON and the host\n    ayon_flame_install()\n\n    return _build_app_menu(\"FlameMenuTimeline\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.load_apps","title":"<code>load_apps()</code>","text":"<p>Load available flame_apps into Flame framework</p> Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def load_apps():\n    \"\"\"Load available flame_apps into Flame framework\n    \"\"\"\n    flame_api.CTX.flame_apps.append(\n        flame_api.FlameMenuProjectConnect(flame_api.CTX.app_framework))\n    flame_api.CTX.flame_apps.append(\n        flame_api.FlameMenuTimeline(flame_api.CTX.app_framework))\n    flame_api.CTX.flame_apps.append(\n        flame_api.FlameMenuUniversal(flame_api.CTX.app_framework))\n    flame_api.CTX.app_framework.log.info(\"Apps are loaded\")\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.project_changed_dict","title":"<code>project_changed_dict(info)</code>","text":"<p>Hook for project change action</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str</code> <p>info text</p> required Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def project_changed_dict(info):\n    \"\"\"Hook for project change action\n\n    Args:\n        info (str): info text\n    \"\"\"\n    cleanup()\n</code></pre>"},{"location":"autoapi/client/ayon_flame/startup/AYON_in_flame.html#client.ayon_flame.startup.AYON_in_flame.project_saved","title":"<code>project_saved(project_name, save_time, is_auto_save)</code>","text":"<p>Hook to activate when project is saved</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of project</p> required <code>save_time</code> <code>str</code> <p>time when it was saved</p> required <code>is_auto_save</code> <code>bool</code> <p>autosave is on or off</p> required Source code in <code>client/ayon_flame/startup/AYON_in_flame.py</code> <pre><code>def project_saved(project_name, save_time, is_auto_save):\n    \"\"\"Hook to activate when project is saved\n\n    Args:\n        project_name (str): name of project\n        save_time (str): time when it was saved\n        is_auto_save (bool): autosave is on or off\n    \"\"\"\n    if flame_api.CTX.app_framework:\n        flame_api.CTX.app_framework.save_prefs()\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/conversion.html","title":"conversion","text":""},{"location":"autoapi/server/settings/create_plugins.html","title":"create_plugins","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/loader_plugins.html","title":"loader_plugins","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""}]}